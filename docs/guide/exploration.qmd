---
title: "Exploratory Modeling"
---

SimOptDecisions supports exploratory modeling to systematically analyze how policies
perform across different states of the world (SOWs). This enables sensitivity analysis,
scenario exploration, and robust decision-making under uncertainty.

## Quick Start

```{julia}
#| eval: false
using SimOptDecisions
using DataFrames

# Run exploration across all policy-SOW combinations
result = explore(config, sows, policies)

# Convert to DataFrame for analysis
df = DataFrame(result)

# Access specific results
result[1, 2]  # policy 1, sow 2
outcomes_for_policy(result, 1)  # all SOWs for policy 1
```

## Parameter Types

To use `explore()`, all fields in your SOW, Policy, and Outcome types must use
parameter types. This enables automatic flattening to tabular format.

| Type | Use Case | Example |
|------|----------|---------|
| `ContinuousParameter{T}` | Real-valued parameters | `ContinuousParameter(0.5)` |
| `DiscreteParameter{T}` | Integer parameters | `DiscreteParameter(10)` |
| `CategoricalParameter{T}` | Categorical values | `CategoricalParameter(:high, [:low, :high])` |
| `TimeSeriesParameter{T}` | Time series data | `TimeSeriesParameter([1.0, 2.0, 3.0])` |

### Defining Types for Exploration

```{julia}
#| eval: false
struct MySOW{T<:AbstractFloat} <: AbstractSOW
    discount_rate::ContinuousParameter{T}
    scenario::CategoricalParameter{Symbol}
    demand::TimeSeriesParameter{T}
end

struct MyPolicy{T<:AbstractFloat} <: AbstractPolicy
    threshold::ContinuousParameter{T}
    buffer_size::DiscreteParameter{Int}
end

# Outcomes must also use parameter types
struct MyOutcome{T<:AbstractFloat}
    npv::ContinuousParameter{T}
    failures::DiscreteParameter{Int}
end
```

### Bounds and Constraints

Parameters can include bounds (useful for optimization):

```{julia}
#| eval: false
# Bounded continuous parameter
ContinuousParameter(0.5, (0.0, 1.0))

# Discrete with valid values
DiscreteParameter(2, [1, 2, 3, 4, 5])

# Categorical with levels
CategoricalParameter(:medium, [:low, :medium, :high])
```

### Time Series Flattening

Time series parameters are expanded to multiple columns in the output:

```{julia}
#| eval: false
struct MySOW <: AbstractSOW
    demand::TimeSeriesParameter{Float64}
end

sow = MySOW(TimeSeriesParameter([10.0, 20.0, 30.0]))
# In results: sow_demand[1]=10.0, sow_demand[2]=20.0, sow_demand[3]=30.0
```

## Running Explorations

The `explore()` function runs simulations for all combinations of policies and SOWs:

```{julia}
#| eval: false
result = explore(
    config,           # Your AbstractConfig
    sows,             # Vector of SOWs
    policies;         # Vector of policies (or single policy)
    progress=true,    # Show progress bar
    rng=Random.default_rng()
)
```

## ExplorationResult

The result is an `ExplorationResult` with several access patterns:

### Indexing

```{julia}
#| eval: false
# Get specific result
result[policy_idx, sow_idx]

# Get all results for one policy
outcomes_for_policy(result, 1)

# Get all results for one SOW
outcomes_for_sow(result, 2)

# Size information
size(result)  # (n_policies, n_sows)
length(result)  # total rows
```

### Tables.jl Integration

`ExplorationResult` implements the Tables.jl interface:

```{julia}
#| eval: false
using DataFrames
df = DataFrame(result)

# Or use with any Tables.jl-compatible sink
using CSV
CSV.write("results.csv", result)
```

### Column Structure

Each row contains:

- `policy_idx`, `sow_idx` — indices into the input vectors
- `policy_*` — flattened policy parameters
- `sow_*` — flattened SOW parameters
- `outcome_*` — flattened outcome fields

### Filtering

```{julia}
#| eval: false
# Filter to specific subset
high_perf = filter(r -> r.outcome_npv > 1000, result)

# Access column categories
result.policy_columns   # Vector{Symbol}
result.sow_columns      # Vector{Symbol}
result.outcome_columns  # Vector{Symbol}
```

## Streaming to File

For large explorations that don't fit in memory, stream results directly to file.

### CSV Output

```{julia}
#| eval: false
using SimOptDecisions
using CSV  # Loads the CSV extension

# Create streaming sink
sink = StreamingSink(csv_sink("results.csv"); flush_every=100)

# Run exploration (returns filepath, not ExplorationResult)
filepath = explore(config, sows, policies; sink=sink)
```

### NetCDF Output

```{julia}
#| eval: false
using SimOptDecisions
using NCDatasets  # Loads the NetCDF extension

# NetCDF sink has built-in buffering
sink = netcdf_sink("results.nc"; flush_every=100)

filepath = explore(config, sows, policies; sink=sink)
```

NetCDF stores data with (policy, sow) dimensions for efficient multidimensional access
and is ideal for large-scale exploratory analyses.

## Visualization

With Makie loaded, several plotting functions are available:

```{julia}
#| eval: false
using CairoMakie

# Heatmap of outcomes across policy-SOW space
fig, ax = plot_exploration(result;
    outcome_field=:npv,
    policy_param=:threshold,
    sow_param=:discount_rate
)

# Parallel coordinates showing parameter-outcome relationships
fig, ax = plot_exploration_parallel(result;
    columns=[:policy_threshold, :sow_discount_rate, :outcome_npv],
    color_by=:outcome_npv
)

# Scatter plot of any two columns
fig, ax = plot_exploration_scatter(result;
    x=:policy_threshold,
    y=:outcome_npv,
    color_by=:sow_scenario
)
```

## SOW Database Pattern

For large time series that would create too many columns, use an index reference pattern:

```{julia}
#| eval: false
# Load SOW database once at module load
const SOW_DATABASE = load("sows.jld2", "sows")

# Lightweight indexed SOW for exploration
struct IndexedSOW <: AbstractSOW
    sow_id::DiscreteParameter{Int}
end

# Look up full SOW data in callbacks
function initialize(config, indexed_sow::IndexedSOW, rng)
    full_sow = SOW_DATABASE[indexed_sow.sow_id.value]
    # ... use full_sow data
end
```

This keeps exploration result tables small while allowing full SOW data access
during simulation.

## Error Messages

If your types don't meet the parameter type requirements, you'll get a helpful error:

```
Cannot use `explore()` with current types:

  - SOW.x :: Float64
  - Policy.threshold :: Float64

All fields must be: ContinuousParameter, DiscreteParameter,
CategoricalParameter, or TimeSeriesParameter.

Note: `simulate()` and `evaluate_policy()` still work without this.
```

This error clearly identifies which fields need to be updated and reminds you
that the standard simulation functions work without parameter types.

## Integration with Optimization

After finding optimal policies via `optimize()`, use `explore()` to understand
their robustness:

```{julia}
#| eval: false
# Optimize to find good policies
opt_result = optimize(prob, backend)

# Extract Pareto-optimal policies
optimal_policies = [
    MyPolicy(ContinuousParameter(p[1]), DiscreteParameter(Int(p[2])))
    for p in opt_result.pareto_params
]

# Explore how they perform across all SOWs
exploration = explore(prob.config, prob.sows, optimal_policies)

# Analyze robustness
df = DataFrame(exploration)
# ... compute statistics, create visualizations
```
