---
title: "House Elevation Under Flood Risk"
subtitle: "A toy problem for decision-making under uncertainty"
author: "Doss-Gollin Lab @ Rice CEVE"
engine: julia
execute:
  exeflags: ["+1.12", "--threads=auto"]
  freeze: false
  cache: false
---

## The Problem

You own a house in a flood-prone coastal area.
Each year, storm surges threaten your property.
You must decide: **how high should you elevate your house?**

Elevating higher costs more upfront, but reduces future flood damages.
The challenge is that you face deep uncertainty about:

- Future storm surge intensity (climate variability)
- The relationship between flood depth and damage
- Future economic conditions (discount rates)

This tutorial demonstrates how to frame this problem using `SimOptDecisions.jl` and explore the trade-off between upfront costs and expected damages.

::: {.callout-tip}
## What You'll Learn

This example builds on the [Investment Growth Example](investment_growth.qmd) and demonstrates:

- **Multi-dimensional uncertainty**: SOW with 6 uncertain parameters
- **Domain-specific physics**: Depth-damage curves, elevation costs
- **Multi-objective optimization**: Trading off construction cost vs expected damages
- **Handling discrete choices**: "Don't elevate" vs "elevate by X feet"

If you haven't read the Investment example, start there first.
:::

## Setup

```{julia}
#| output: false
# Activate the docs environment
using Pkg: Pkg
Pkg.activate(dirname(dirname(@__FILE__)))
```

```{julia}
#| output: false
using Revise
using SimOptDecisions
using Distributions
using Random
using CairoMakie
```

## Defining the Uncertainty

### State of the World (SOW)

Each SOW represents one possible future scenario.
We model uncertainty in:

1. **Storm surge distribution**: Annual maximum surge heights follow a Generalized Extreme Value (GEV) distribution, measured at a nearby tide gauge
2. **Depth-damage relationship**: How flood depth at the house translates to damage
3. **Discount rate**: The time value of money

```{julia}
#| output: false
struct HouseElevationSOW{T<:AbstractFloat} <: AbstractSOW
    # GEV parameters for annual max surge at the gauge
    gev_μ::T  # location (ft)
    gev_σ::T  # scale (ft)
    gev_ξ::T  # shape (dimensionless)

    # Depth-damage curve parameters (at the house)
    dd_threshold::T   # depth below which no damage occurs (ft)
    dd_saturation::T  # depth at which damage reaches 100% (ft)

    # Economic parameters
    discount_rate::T
end
```

### Sampling SOWs

We generate random SOWs by sampling from prior distributions on each parameter.
This represents our uncertainty about the true values.

We use GEV parameters inspired by the Sewells Point tide gauge in Norfolk, VA (NOAA Station 8638610).
Annual maximum water levels at this location are typically 2-4 ft above Mean Higher High Water (MHHW), with major hurricanes producing 6-8+ ft surges (e.g., Hurricane Isabel in 2003 reached ~7.9 ft above MHHW).

::: {.callout-note}
## Simplified Uncertainty Model

This is an intentionally simplified approach to uncertainty for pedagogical purposes.
In a real application, you would want to consider non-stationary extremes (climate change effects on storm intensity), spatial correlation between gauge and house, and more sophisticated uncertainty quantification methods.
:::

```{julia}
#| output: false
function sample_sow(rng::AbstractRNG)
    # GEV parameters for annual max water level at Sewells Point, Norfolk VA
    # Values are in feet above MHHW
    # Based on historical observations: typical annual max ~2.5-3 ft, major storms 6-8+ ft
    gev_μ = rand(rng, Normal(2.8, 0.3))   # location: typical annual max (ft above MHHW)
    gev_σ = rand(rng, truncated(Normal(1.0, 0.15); lower=0.3))  # scale: spread of extremes
    gev_ξ = rand(rng, truncated(Normal(0.15, 0.05); lower=-0.2, upper=0.5))  # shape: tail behavior

    # Depth-damage curve parameters (at house)
    # No damage below ~0 ft at house floor, full damage around 8 ft
    dd_threshold = rand(rng, Normal(0.0, 0.25))
    dd_saturation = rand(rng, Normal(8.0, 0.5))

    # Discount rate: uncertain, ranging from ~1% to 7%
    discount_rate = rand(rng, truncated(Normal(0.03, 0.015); lower=0.01, upper=0.07))

    return HouseElevationSOW(
        gev_μ, gev_σ, gev_ξ, dd_threshold, dd_saturation, discount_rate
    )
end
```

## The Decision: Elevation Policy

For this example, we consider a **static policy**: choose an elevation height once, at the beginning, and live with that decision for the entire planning horizon.

### Action

The action represents the decision variable—how much to elevate:

```{julia}
#| output: false
struct ElevationAction{T<:AbstractFloat} <: AbstractAction
    elevation_ft::T  # feet above current ground level (0-14)
end
```

### Policy

```{julia}
#| output: false
struct ElevationPolicy{T<:AbstractFloat} <: AbstractPolicy
    elevation_ft::T  # feet above current ground level (0-14)
end

# For optimization, we need to define how to convert between policy and parameter vector
ElevationPolicy(params::AbstractVector) = ElevationPolicy(params[1])
SimOptDecisions.params(p::ElevationPolicy) = [p.elevation_ft]
SimOptDecisions.param_bounds(::Type{<:ElevationPolicy}) = [(1.0, 14.0)]
```

::: {.callout-note}
## Modeling Choice: Binary vs Continuous Decisions

Note that `param_bounds` is `[(1.0, 14.0)]`, not `[(0.0, 14.0)]`. This is a deliberate modeling decision.

**The real decision has two parts:**

1. **Whether to elevate** (binary: yes/no)
2. **If yes, how high** (continuous: 1-14 ft)

Metaheuristics.jl optimizes continuous parameters, so we optimize over "if you elevate, how high?"
and evaluate "don't elevate" separately as a baseline.

**Alternative approaches for mixed discrete/continuous problems:**

- Use penalty functions to discourage near-zero elevations
- Round to discrete levels and optimize over integers
- Use a hierarchical policy with separate binary and continuous parameters
- Use optimization backends that support mixed-integer problems

For this pedagogical example, explicitly separating the choices is clearest.
:::

```{julia}
#| output: false
# Define the action: for a static policy, x_t = X^π(S_t) is just the policy's elevation
function SimOptDecisions.get_action(
    policy::ElevationPolicy,
    state,  # unused for static policy
    sow::HouseElevationSOW,
    t::TimeStep,
)
    return ElevationAction(policy.elevation_ft)
end
```

## The Model

### Model Definition

The model encapsulates parameters that are **shared across all SOWs and policies**.
These are fixed characteristics of the problem, not uncertain quantities.
We use values from [Doss-Gollin et al. (2022)](https://github.com/jdossgollin/2022-elevation-robustness): a 1500 ft² house worth \$200,000 with a 70-year planning horizon.

```{julia}
#| output: false
Base.@kwdef struct HouseElevationConfig{T<:AbstractFloat} <: AbstractConfig
    horizon::Int = 70                  # planning horizon (years)
    gauge_to_house::T = 4.0            # surge level at which water reaches house floor (ft)
    house_area_ft2::T = 1500.0         # floor area in square feet
    house_value::T = 200_000.0         # house value in dollars (not land)
end
```

### Depth-Damage Function

The depth-damage function converts flood depth (at the house) to fractional damage.
We use a logistic curve with a threshold and saturation point.

```{julia}
#| output: false
function depth_damage(depth::T, threshold::T, saturation::T) where {T<:AbstractFloat}
    # No damage if water doesn't reach the floor
    depth <= threshold && return zero(T)
    # Full damage if deeply flooded
    depth >= saturation && return one(T)
    # Logistic transition between threshold and saturation
    midpoint = (threshold + saturation) / 2
    steepness = T(6) / (saturation - threshold)  # reaches ~95% at saturation
    return one(T) / (one(T) + exp(-steepness * (depth - midpoint)))
end
```

We can visualize how damage increases with flood depth:

```{julia}
#| label: fig-depth-damage
#| fig-cap: "Depth-damage function showing fractional damage as a function of flood depth at the house"
#| code-fold: true
let
    depths = range(-1, 10; length=200)
    fig = Figure(; size=(600, 400))
    ax = Axis(
        fig[1, 1];
        xlabel="Flood depth at house (ft)",
        ylabel="Damage (fraction of house value)",
        title="Depth-Damage Function",
    )

    # Show for nominal parameters
    damages = [depth_damage(d, 0.0, 8.0) for d in depths]
    lines!(ax, depths, damages; linewidth=2, label="Nominal (threshold=0, sat=8)")

    # Show uncertainty range
    for (thresh, sat) in [(-0.5, 7.5), (0.5, 8.5)]
        damages_alt = [depth_damage(d, thresh, sat) for d in depths]
        lines!(ax, depths, damages_alt; linewidth=1, linestyle=:dash, alpha=0.5)
    end

    axislegend(ax; position=:rb)
    fig
end
```

### Elevation Cost Function

The cost to elevate a house increases with height.
We use the cost model from [Doss-Gollin et al. (2022)](https://github.com/jdossgollin/2022-elevation-robustness), which is based on USACE cost estimates: a fixed base cost plus a per-square-foot cost that increases with elevation height.

```{julia}
#| output: false
"""
	elevation_cost(Δh, area_ft2, house_value)

Compute elevation cost as a fraction of house value.
Based on USACE cost estimates with piecewise-linear rates.
"""
function elevation_cost(Δh::Real, area_ft2::Real, house_value::Real)
    Δh <= 0 && return 0.0
    Δh > 14 && error("Cannot elevate more than 14 ft")

    # Cost structure from Doss-Gollin et al. (2022)
    # Base cost covers permits, engineering, temporary relocation, etc.
    base_cost = 10_000 + 300 + 470 + 4_300 + 2_175 + 3_500  # = $20,745

    # Per-square-foot rates increase with elevation height ($/ft²)
    # These are interpolated based on elevation
    thresholds = [0.0, 5.0, 8.5, 12.0, 14.0]
    rates = [80.36, 82.5, 86.25, 103.75, 113.75]

    # Linear interpolation of rate
    rate = rates[1]
    for i in 1:(length(thresholds) - 1)
        if Δh <= thresholds[i + 1]
            t = (Δh - thresholds[i]) / (thresholds[i + 1] - thresholds[i])
            rate = rates[i] + t * (rates[i + 1] - rates[i])
            break
        end
        rate = rates[i + 1]
    end

    cost_dollars = base_cost + area_ft2 * rate
    return cost_dollars / house_value
end

# Convenience wrapper using default house parameters
elevation_cost(Δh::Real) = elevation_cost(Δh, 1500.0, 200_000.0)
```

We can plot the cost curve to see how expenses grow with elevation height:

```{julia}
#| label: fig-elevation-cost
#| fig-cap: "Construction cost to elevate the house as a function of elevation height"
#| code-fold: true
let
    heights = 0:14
    costs = [elevation_cost(h) for h in heights]

    fig = Figure(; size=(600, 400))
    ax = Axis(
        fig[1, 1];
        xlabel="Elevation height (ft)",
        ylabel="Cost (fraction of house value)",
        title="Elevation Cost Function (1500 ft², \$200k house)",
    )
    scatterlines!(ax, heights, costs; markersize=10)
    fig
end
```

## Implementing the Simulation

Now we implement the simulation using the `TimeStepping` interface.
This provides a structured way to define time-stepped simulations with five callbacks:

1. `initialize` - Create initial state (this model is stateless, so returns `nothing`)
2. `get_action` - Map policy + state to action (already defined above)
3. `run_timestep` - Execute one year: sample surge, compute damage
4. `time_axis` - Define the time points (years 1 to horizon)
5. `finalize` - Aggregate annual damages into NPV

### Initialize

Since flood damage in one year doesn't affect the house's vulnerability in the next year (beyond the elevation decision), this model has no persistent state between timesteps:

```{julia}
#| output: false
function SimOptDecisions.TimeStepping.initialize(
    ::HouseElevationConfig, ::HouseElevationSOW, ::AbstractRNG
)
    return nothing
end
```

### Time Axis

We simulate year-by-year over the planning horizon:

```{julia}
#| output: false
function SimOptDecisions.TimeStepping.time_axis(config::HouseElevationConfig, ::HouseElevationSOW)
    return 1:(config.horizon)
end
```

### Run Timestep

Each year, we sample a storm surge from the GEV distribution and compute the resulting damage.
The framework calls `get_action(policy, state, sow, t)` before this function, so we receive the elevation decision directly as `action`:

```{julia}
#| output: false
function SimOptDecisions.TimeStepping.run_timestep(
    state::Nothing,
    action::ElevationAction,
    sow::HouseElevationSOW,
    config::HouseElevationConfig,
    t::TimeStep,
    rng::AbstractRNG,
)
    # Construction cost is incurred at t=1 only
    construction_cost = if t.t == 1
        elevation_cost(action.elevation_ft, config.house_area_ft2, config.house_value)
    else
        0.0
    end

    # Sample annual maximum surge at the gauge
    surge_dist = GeneralizedExtremeValue(sow.gev_μ, sow.gev_σ, sow.gev_ξ)
    surge_at_gauge = rand(rng, surge_dist)

    # Compute flood depth at house
    # gauge_to_house is the surge level at which water reaches the (unelevated) house floor
    # With elevation, we need (gauge_to_house + elevation) surge to start flooding
    flood_depth_at_house = surge_at_gauge - (config.gauge_to_house + action.elevation_ft)

    # Compute fractional damage
    damage_fraction = depth_damage(flood_depth_at_house, sow.dd_threshold, sow.dd_saturation)

    step_record = (construction_cost=construction_cost, damage_fraction=damage_fraction)
    return (nothing, step_record)
end
```

### Finalize

After all timesteps, we aggregate the annual damages into a net present value (NPV) using the SOW's discount rate:

```{julia}
#| output: false
function SimOptDecisions.TimeStepping.finalize(
    ::Nothing,
    step_records::Vector,
    config::HouseElevationConfig,
    sow::HouseElevationSOW,
)
    construction_cost = step_records[1].construction_cost

    npv_damages = sum(
        step_records[t].damage_fraction * SimOptDecisions.Utils.discount_factor(sow.discount_rate, t)
        for t in eachindex(step_records)
    )

    return (
        construction_cost=construction_cost,
        npv_damages=npv_damages,
        annual_damages=[o.damage_fraction for o in step_records],
    )
end
```

Note: No need to override `simulate()` - the framework automatically calls these TimeStepping callbacks in sequence.

## Running the Analysis

### Generate SOWs

First, we sample a large ensemble of possible futures.

```{julia}
#| output: false
n_sows = 1000
rng = Random.Xoshiro(42)  # reproducibility
sows = [sample_sow(rng) for _ in 1:n_sows]
```

### Evaluate Each Elevation Level

For each possible elevation (0-14 ft), we simulate across all SOWs and collect the NPV damages.

```{julia}
#| output: false
config = HouseElevationConfig()
elevations = 0:14

# Store results: for each elevation, vector of NPV damages across SOWs
results = Dict{Int,Vector{Float64}}()

for elev in elevations
    policy = ElevationPolicy(Float64(elev))
    outcomes = [simulate(config, sow, policy).npv_damages for sow in sows]
    results[elev] = outcomes
end
```

## Results and Visualization

### Trade-off Curve

The key insight is the trade-off between upfront cost (elevation) and expected future damages.

```{julia}
#| label: fig-tradeoff
#| fig-cap: "Trade-off between construction cost and expected NPV damages. Each point represents an elevation level (0-14 ft)."
#| code-fold: true
let
    construction_costs = [elevation_cost(e) for e in elevations]
    expected_damages = [mean(results[e]) for e in elevations]

    fig = Figure(; size=(700, 500))
    ax = Axis(
        fig[1, 1];
        xlabel="Construction cost (fraction of house value)",
        ylabel="Expected NPV damages (fraction of house value)",
        title="Cost-Damage Trade-off by Elevation Level",
    )

    scatter!(ax, construction_costs, expected_damages; markersize=15)

    # Label points with elevation
    for (i, elev) in enumerate(elevations)
        text!(
            ax,
            construction_costs[i],
            expected_damages[i];
            text=string(elev),
            align=(:left, :bottom),
            offset=(5, 5),
        )
    end

    fig
end
```

### Total Cost Analysis

Let's look at the total cost (construction + expected damages) for each elevation level.

```{julia}
#| label: fig-total-cost
#| fig-cap: "Total expected cost (construction + NPV damages) by elevation level"
#| code-fold: true
let
    construction_costs = [elevation_cost(e) for e in elevations]
    expected_damages = [mean(results[e]) for e in elevations]
    total_costs = construction_costs .+ expected_damages

    fig = Figure(; size=(700, 500))
    ax = Axis(
        fig[1, 1];
        xlabel="Elevation (ft)",
        ylabel="Total expected cost (fraction of house value)",
        title="Total Cost by Elevation Level",
    )

    barplot!(ax, collect(elevations), total_costs; color=:steelblue)

    # Mark the minimum
    min_idx = argmin(total_costs)
    scatter!(
        ax,
        [elevations[min_idx]],
        [total_costs[min_idx]];
        color=:red,
        markersize=20,
        marker=:star5,
    )

    fig
end
```

### Uncertainty in Damages

The expected value doesn't tell the whole story. Let's examine the full distribution of outcomes.

```{julia}
#| label: fig-uncertainty
#| fig-cap: "Distribution of NPV damages for each elevation level. Box shows 25th-75th percentile; whiskers show 5th-95th percentile."
#| code-fold: true
let
    fig = Figure(; size=(800, 500))
    ax = Axis(
        fig[1, 1];
        xlabel="Elevation (ft)",
        ylabel="NPV damages (fraction of house value)",
        title="Damage Uncertainty by Elevation Level",
    )

    # Compute quantiles for each elevation
    for elev in elevations
        damages = results[elev]
        q05 = quantile(damages, 0.05)
        q25 = quantile(damages, 0.25)
        q50 = quantile(damages, 0.50)
        q75 = quantile(damages, 0.75)
        q95 = quantile(damages, 0.95)

        # Whiskers (5-95)
        lines!(ax, [elev, elev], [q05, q95]; color=:gray, linewidth=1)
        # Box (25-75)
        poly!(
            ax,
            Point2f[
                (elev - 0.3, q25), (elev + 0.3, q25), (elev + 0.3, q75), (elev - 0.3, q75)
            ];
            color=(:steelblue, 0.5),
            strokecolor=:black,
            strokewidth=1,
        )
        # Median
        lines!(ax, [elev - 0.3, elev + 0.3], [q50, q50]; color=:black, linewidth=2)
    end

    fig
end
```

### Sensitivity to Discount Rate

How does the "optimal" elevation depend on the discount rate?

```{julia}
#| label: fig-sensitivity
#| fig-cap: "Optimal elevation as a function of discount rate. Lower discount rates favor more elevation (future damages weigh more heavily)."
#| code-fold: true
let
    # Group SOWs by discount rate bins
    rate_bins = [0.015, 0.025, 0.035, 0.045, 0.055, 0.065]
    optimal_by_rate = Float64[]

    for rate in rate_bins
        # Filter SOWs near this discount rate
        filtered_sows = filter(s -> abs(s.discount_rate - rate) < 0.005, sows)
        if length(filtered_sows) < 10
            push!(optimal_by_rate, NaN)
            continue
        end

        # For these SOWs, find elevation with lowest total cost
        best_elev = 0
        best_cost = Inf
        for elev in elevations
            policy = ElevationPolicy(Float64(elev))
            outcomes = [simulate(config, sow, policy).npv_damages for sow in filtered_sows]
            total = elevation_cost(elev) + mean(outcomes)
            if total < best_cost
                best_cost = total
                best_elev = elev
            end
        end
        push!(optimal_by_rate, best_elev)
    end

    fig = Figure(; size=(600, 400))
    ax = Axis(
        fig[1, 1];
        xlabel="Discount rate",
        ylabel="Optimal elevation (ft)",
        title="Sensitivity to Discount Rate",
    )

    scatterlines!(ax, rate_bins, optimal_by_rate; markersize=12)
    fig
end
```

## Multi-Objective Optimization

The grid search above explored the trade-offs manually.
`SimOptDecisions.jl` can automate this with multi-objective optimization.

### Understanding Outcomes vs Metrics

Before setting up optimization, it's important to understand two key concepts:

- **Outcome**: The result of a *single* simulation (one policy × one SOW). This is what `simulate` returns—in our case, a `NamedTuple` with `construction_cost`, `npv_damages`, and `annual_damages`.

- **Metric**: An *aggregated* statistic computed across many SOWs for a given policy. For example, `mean(outcomes.npv_damages)` or `quantile(outcomes.npv_damages, 0.95)`.

The optimizer evaluates policies by computing metrics across the SOW ensemble, then optimizes those metrics.

### Defining a Metric Calculator

We need a function that takes a vector of outcomes and returns named metrics:

```{julia}
#| output: false
using Statistics: mean, quantile

"""
Compute metrics from outcomes across many SOWs.
Returns a NamedTuple that the optimizer can reference.
"""
function calculate_metrics(outcomes)
    damages = [o.npv_damages for o in outcomes]
    # Construction cost is now part of the outcome (same for all SOWs with same policy)
    construction = outcomes[1].construction_cost
    return (
        construction_cost=construction,
        expected_damage=mean(damages),
        cvar_95=mean(sort(damages)[(end - max(1, length(damages) ÷ 20)):end]),  # CVaR at 95%
        worst_case=maximum(damages),
    )
end
```

### Setting Up Multi-Objective Optimization

Now we can set up a problem that trades off upfront construction cost against expected future damages.
These are **conflicting objectives**: higher elevation costs more upfront but reduces damages.

```{julia}
#| output: false
import Metaheuristics  # loads extension for SimOptDecisions.optimize

# Create the optimization problem
prob = OptimizationProblem(
    config,
    sows,
    ElevationPolicy,
    calculate_metrics,
    [minimize(:construction_cost), minimize(:expected_damage)];
)
```

### Running the Optimization

```{julia}
# Run multi-objective optimization using NSGA-II
# parallel=true enables batch fitness evaluation across Julia threads
backend = MetaheuristicsBackend(;
    algorithm=:NSGA2, max_iterations=100, population_size=30, parallel=true
)
```

```{julia}
opt_result = SimOptDecisions.optimize(prob, backend)
```

We should also evaluate the "don't elevate" baseline (0 ft) separately, since that's a distinct decision:

```{julia}
#| output: false
# Evaluate no-elevation baseline
no_elevate_outcomes = [simulate(config, sow, ElevationPolicy(0.0)) for sow in sows]
no_elevate_metrics = calculate_metrics(no_elevate_outcomes)
println("No elevation: cost=0.0, expected_damage=$(round(no_elevate_metrics.expected_damage, digits=3))")
```

### Visualizing the Pareto Front

The optimization returns a set of Pareto-optimal solutions—policies where you cannot improve one objective without worsening another:

```{julia}
#| label: fig-pareto
#| fig-cap: "Pareto front showing trade-off between construction cost and expected NPV damages. The red diamond shows the no-elevation baseline."
#| code-fold: true
let
    fig = Figure(; size=(700, 500))
    ax = Axis(
        fig[1, 1];
        xlabel="Construction cost (fraction of house value)",
        ylabel="Expected NPV damages (fraction of house value)",
        title="Pareto Front: Construction Cost vs Expected Damage",
    )

    # Plot the no-elevation baseline
    scatter!(ax, [0.0], [no_elevate_metrics.expected_damage];
        markersize=20, color=:red, marker=:diamond, label="No elevation (0 ft)")

    # Extract Pareto front from optimization
    pareto_pts = collect(SimOptDecisions.pareto_front(opt_result))

    if !isempty(pareto_pts)
        construction = [obj[1] for (_, obj) in pareto_pts]
        expected = [obj[2] for (_, obj) in pareto_pts]
        elevations = [round(p[1]; digits=1) for (p, _) in pareto_pts]

        scatter!(ax, construction, expected; markersize=12, color=:steelblue, label="Pareto front")

        # Label a subset of points with elevation (avoid clutter)
        labeled = Set{Float64}()
        for (i, elev) in enumerate(elevations)
            # Only label if not too close to already-labeled point
            if all(abs(elev - l) > 1.5 for l in labeled)
                text!(ax, construction[i], expected[i];
                    text=string(round(Int, elev)), align=(:left, :bottom), offset=(5, 5))
                push!(labeled, elev)
            end
        end
    end

    axislegend(ax; position=:rt)
    fig
end
```

### Interpreting Results

The Pareto front reveals the fundamental trade-off:

- **No elevation (0 ft)** has zero construction cost but the highest expected damages
- **Lower elevations (1-4 ft)** have moderate construction costs with significant damage reduction
- **Higher elevations (8+ ft)** provide excellent protection but at substantial upfront cost
- The "best" choice depends on your **risk tolerance** and **budget constraints**

```{julia}
# Show the best policy found (by first objective)
println("Best policy found: ", opt_result.best_policy)
println(
    "Objectives: construction_cost = $(round(opt_result.best_objectives[1], digits=3)), ",
    "expected_damage = $(round(opt_result.best_objectives[2], digits=3))",
)
```

## Discussion

This toy problem illustrates several key concepts:

1. **Decision under uncertainty**: There is no single "correct" elevation. The choice depends on your beliefs about future storms, your risk tolerance, and how you value present vs. future costs.

2. **Trade-offs are fundamental**: Lower elevation saves money now but increases expected future damages. Higher elevation costs more upfront but provides protection.

3. **Deep uncertainty matters**: The uncertainty in outcomes (see @fig-uncertainty) can be substantial. Risk-averse decision-makers might prefer elevations that reduce worst-case outcomes, even if expected costs are slightly higher.

4. **Multi-objective optimization** helps explore these trade-offs systematically, revealing the Pareto frontier of non-dominated solutions.

## Summary: Adapting This Example

This example showed a more complex application of the framework. Here's what you'd change for your own problem:

### Key Components to Customize

| Component | This Example | Your Model |
|-----------|--------------|------------|
| **SOW** | Storm surge (GEV), damage curve, discount rate | Your uncertain parameters |
| **Config** | House size, value, planning horizon | Your fixed model constants |
| **Action** | Elevation height | Your decision variables |
| **Policy** | Static elevation choice | Your decision rule |
| **run_timestep** | Sample surge, compute damage | Your transition dynamics |
| **finalize** | NPV calculation | Your outcome aggregation |
| **calculate_metrics** | Expected damage, construction cost | Your optimization objectives |

### Lessons for Your Application

1. **Structure your uncertainty**: Put all uncertain quantities in the SOW. Sample many SOWs to test robustness.

2. **Separate physics from decisions**: The depth-damage curve and elevation cost functions are domain knowledge—keep them separate from the framework machinery.

3. **Handle discrete choices explicitly**: When you have mixed continuous/discrete decisions, consider whether to optimize them jointly or separately.

4. **Use multi-objective optimization** when trade-offs matter. The Pareto front shows you what's achievable—choosing a point on it is a separate (human) decision.

5. **Validate with grid search first**: Before running optimization, explore the space manually (like we did with 0-14 ft elevations). This catches bugs and builds intuition.

For more advanced usage, see the [package documentation](https://github.com/dossgollin-lab/SimOptDecisions.jl).
