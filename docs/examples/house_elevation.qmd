---
title: "House Elevation Under Flood Risk"
subtitle: "A toy problem for decision-making under uncertainty"
author: "Doss-Gollin Lab @ Rice CEVE"
engine: julia
execute:
  exeflags: ["+1.12", "--threads=auto"]
  freeze: false
  cache: false
---

## The Problem

You own a house in a flood-prone coastal area.
Each year, storm surges threaten your property.
You must decide: **how high should you elevate your house?**

Elevating higher costs more upfront, but reduces future flood damages.
The challenge is that you face deep uncertainty about:

- Future storm surge intensity (climate variability)
- The relationship between flood depth and damage
- Future economic conditions (discount rates)

This tutorial demonstrates how to frame this problem using `SimOptDecisions.jl` and explore the trade-off between upfront costs and expected damages.

## Setup

```{julia}
#| output: false
# Activate the docs environment
using Pkg: Pkg
Pkg.activate(dirname(dirname(@__FILE__)))
```

```{julia}
#| output: false
using Revise
using SimOptDecisions
using Distributions
using Random
using CairoMakie
```

## Defining the Uncertainty

### State of the World (SOW)

Each SOW represents one possible future scenario.
We model uncertainty in:

1. **Storm surge distribution**: Annual maximum surge heights follow a Generalized Extreme Value (GEV) distribution, measured at a nearby tide gauge
2. **Depth-damage relationship**: How flood depth at the house translates to damage
3. **Discount rate**: The time value of money

```{julia}
#| output: false
struct HouseElevationSOW{T<:AbstractFloat} <: AbstractSOW
    # GEV parameters for annual max surge at the gauge
    gev_μ::T  # location (ft)
    gev_σ::T  # scale (ft)
    gev_ξ::T  # shape (dimensionless)

    # Depth-damage curve parameters (at the house)
    dd_threshold::T   # depth below which no damage occurs (ft)
    dd_saturation::T  # depth at which damage reaches 100% (ft)

    # Economic parameters
    discount_rate::T
end
```

### Sampling SOWs

We generate random SOWs by sampling from prior distributions on each parameter.
This represents our uncertainty about the true values.

We use GEV parameters inspired by the Sewells Point tide gauge in Norfolk, VA (NOAA Station 8638610).
Annual maximum water levels at this location are typically 2-4 ft above Mean Higher High Water (MHHW), with major hurricanes producing 6-8+ ft surges (e.g., Hurricane Isabel in 2003 reached ~7.9 ft above MHHW).

```{julia}
#| output: false
function sample_sow(rng::AbstractRNG)
    # GEV parameters for annual max water level at Sewells Point, Norfolk VA
    # Values are in feet above MHHW
    # Based on historical observations: typical annual max ~2.5-3 ft, major storms 6-8+ ft
    gev_μ = rand(rng, Normal(2.8, 0.3))   # location: typical annual max (ft above MHHW)
    gev_σ = rand(rng, truncated(Normal(1.0, 0.15); lower=0.3))  # scale: spread of extremes
    gev_ξ = rand(rng, truncated(Normal(0.15, 0.05); lower=-0.2, upper=0.5))  # shape: tail behavior

    # Depth-damage curve parameters (at house)
    # No damage below ~0 ft at house floor, full damage around 8 ft
    dd_threshold = rand(rng, Normal(0.0, 0.25))
    dd_saturation = rand(rng, Normal(8.0, 0.5))

    # Discount rate: ~2.5% with uncertainty (following Doss-Gollin et al. 2022)
    discount_rate = rand(rng, truncated(Normal(0.025, 0.01); lower=0.01, upper=0.06))

    return HouseElevationSOW(
        gev_μ, gev_σ, gev_ξ, dd_threshold, dd_saturation, discount_rate
    )
end
```

## The Decision: Elevation Policy

For this example, we consider a **static policy**: choose an elevation height once, at the beginning, and live with that decision for the entire planning horizon.

```{julia}
#| output: false
struct ElevationPolicy{T<:AbstractFloat} <: AbstractPolicy
    elevation_ft::T  # feet above current ground level (0-14)
end

# For optimization, we need to define how to convert between policy and parameter vector
ElevationPolicy(params::AbstractVector) = ElevationPolicy(params[1])
SimOptDecisions.params(p::ElevationPolicy) = [p.elevation_ft]
SimOptDecisions.param_bounds(::Type{<:ElevationPolicy}) = [(0.0, 14.0)]

# Define the action: for a static policy, x_t = X^π(S_t) is just the policy's elevation
# This is a Policy Function Approximation (PFA) - a direct mapping from state to action
function SimOptDecisions.get_action(
    policy::ElevationPolicy,
    state,  # unused for static policy
    sow::HouseElevationSOW,
    t::TimeStep,
)
    return (elevation_ft=policy.elevation_ft,)
end
```

The optimizer will search over continuous elevation values in [0, 14].
We'll also evaluate integer heights 0:14 for comparison.

## The Model

### Model Definition

The model encapsulates parameters that are **shared across all SOWs and policies**.
These are fixed characteristics of the problem, not uncertain quantities.
We use values from [Doss-Gollin et al. (2022)](https://github.com/jdossgollin/2022-elevation-robustness): a 1500 ft² house worth \$200,000 with a 70-year planning horizon.

```{julia}
#| output: false
Base.@kwdef struct HouseElevationParams{T<:AbstractFloat} <: AbstractConfig
    horizon::Int = 70                  # planning horizon (years)
    gauge_to_house::T = 5.0            # surge level at which water reaches house floor (ft)
    house_area_ft2::T = 1500.0         # floor area in square feet
    house_value::T = 200_000.0         # house value in dollars (not land)
end
```

### Depth-Damage Function

The depth-damage function converts flood depth (at the house) to fractional damage.
We use a logistic curve with a threshold and saturation point.

```{julia}
#| output: false
function depth_damage(depth::T, threshold::T, saturation::T) where {T<:AbstractFloat}
    # No damage if water doesn't reach the floor
    depth <= threshold && return zero(T)
    # Full damage if deeply flooded
    depth >= saturation && return one(T)
    # Logistic transition between threshold and saturation
    midpoint = (threshold + saturation) / 2
    steepness = T(6) / (saturation - threshold)  # reaches ~95% at saturation
    return one(T) / (one(T) + exp(-steepness * (depth - midpoint)))
end
```

We can visualize how damage increases with flood depth:

```{julia}
#| label: fig-depth-damage
#| fig-cap: "Depth-damage function showing fractional damage as a function of flood depth at the house"
#| code-fold: true
let
    depths = range(-1, 10; length=200)
    fig = Figure(; size=(600, 400))
    ax = Axis(
        fig[1, 1];
        xlabel="Flood depth at house (ft)",
        ylabel="Damage (fraction of house value)",
        title="Depth-Damage Function",
    )

    # Show for nominal parameters
    damages = [depth_damage(d, 0.0, 8.0) for d in depths]
    lines!(ax, depths, damages; linewidth=2, label="Nominal (threshold=0, sat=8)")

    # Show uncertainty range
    for (thresh, sat) in [(-0.5, 7.5), (0.5, 8.5)]
        damages_alt = [depth_damage(d, thresh, sat) for d in depths]
        lines!(ax, depths, damages_alt; linewidth=1, linestyle=:dash, alpha=0.5)
    end

    axislegend(ax; position=:rb)
    fig
end
```

### Elevation Cost Function

The cost to elevate a house increases with height.
We use the cost model from [Doss-Gollin et al. (2022)](https://github.com/jdossgollin/2022-elevation-robustness), which is based on USACE cost estimates: a fixed base cost plus a per-square-foot cost that increases with elevation height.

```{julia}
#| output: false
"""
	elevation_cost(Δh, area_ft2, house_value)

Compute elevation cost as a fraction of house value.
Based on USACE cost estimates with piecewise-linear rates.
"""
function elevation_cost(Δh::Real, area_ft2::Real, house_value::Real)
    Δh <= 0 && return 0.0
    Δh > 14 && error("Cannot elevate more than 14 ft")

    # Cost structure from Doss-Gollin et al. (2022)
    # Base cost covers permits, engineering, temporary relocation, etc.
    base_cost = 10_000 + 300 + 470 + 4_300 + 2_175 + 3_500  # = $20,745

    # Per-square-foot rates increase with elevation height ($/ft²)
    # These are interpolated based on elevation
    thresholds = [0.0, 5.0, 8.5, 12.0, 14.0]
    rates = [80.36, 82.5, 86.25, 103.75, 113.75]

    # Linear interpolation of rate
    rate = rates[1]
    for i in 1:(length(thresholds) - 1)
        if Δh <= thresholds[i + 1]
            t = (Δh - thresholds[i]) / (thresholds[i + 1] - thresholds[i])
            rate = rates[i] + t * (rates[i + 1] - rates[i])
            break
        end
        rate = rates[i + 1]
    end

    cost_dollars = base_cost + area_ft2 * rate
    return cost_dollars / house_value
end

# Convenience wrapper using default house parameters
elevation_cost(Δh::Real) = elevation_cost(Δh, 1500.0, 200_000.0)
```

We can plot the cost curve to see how expenses grow with elevation height:

```{julia}
#| label: fig-elevation-cost
#| fig-cap: "Construction cost to elevate the house as a function of elevation height"
#| code-fold: true
let
    heights = 0:14
    costs = [elevation_cost(h) for h in heights]

    fig = Figure(; size=(600, 400))
    ax = Axis(
        fig[1, 1];
        xlabel="Elevation height (ft)",
        ylabel="Cost (fraction of house value)",
        title="Elevation Cost Function (1500 ft², \$200k house)",
    )
    scatterlines!(ax, heights, costs; markersize=10)
    fig
end
```

## Implementing the Simulation

Now we implement the simulation using the `TimeStepping` interface.
This provides a structured way to define time-stepped simulations with four callbacks:

1. `initialize` - Create initial state (this model is stateless, so returns `nothing`)
2. `run_timestep` - Execute one year: sample surge, compute damage
3. `time_axis` - Define the time points (years 1 to horizon)
4. `finalize` - Aggregate annual damages into NPV

```{julia}
#| output: false
# Initialize: this model has no state between years
function SimOptDecisions.TimeStepping.initialize(
    ::HouseElevationParams, ::HouseElevationSOW, ::AbstractRNG
)
    return nothing
end

# Run one timestep: sample surge, compute damage
function SimOptDecisions.TimeStepping.run_timestep(
    state::Nothing,
    params::HouseElevationParams,
    sow::HouseElevationSOW,
    policy::ElevationPolicy,
    t::TimeStep,
    rng::AbstractRNG,
)
    # Get the action (elevation) from the policy
    action = get_action(policy, state, sow, t)

    # Construction cost is incurred at t=1 only
    construction_cost = t.t == 1 ? elevation_cost(action.elevation_ft, params.house_area_ft2, params.house_value) : 0.0

    # Sample annual maximum surge at the gauge (exogenous information)
    surge_dist = GeneralizedExtremeValue(sow.gev_μ, sow.gev_σ, sow.gev_ξ)
    surge_at_gauge = rand(rng, surge_dist)

    # Compute flood depth given action and exogenous info
    # gauge_to_house is the surge level at which water reaches the (unelevated) house floor
    # With elevation, we need (gauge_to_house + elevation) surge to start flooding
    flood_depth_at_house = surge_at_gauge - (params.gauge_to_house + action.elevation_ft)

    # Compute fractional damage this year
    damage_fraction = depth_damage(flood_depth_at_house, sow.dd_threshold, sow.dd_saturation)

    # Return step output with both construction cost and damage
    step_record = (construction_cost=construction_cost, damage_fraction=damage_fraction)
    return (nothing, step_record)
end

# Time axis: years 1 to horizon
function SimOptDecisions.TimeStepping.time_axis(params::HouseElevationParams, ::HouseElevationSOW)
    return 1:(params.horizon)
end

# Finalize: aggregate construction cost and discount annual damages to NPV
function SimOptDecisions.TimeStepping.finalize(
    ::Nothing,
    step_records::Vector,
    params::HouseElevationParams,
    sow::HouseElevationSOW,
)
    # Extract construction cost (only non-zero at t=1)
    construction_cost = step_records[1].construction_cost

    # Compute NPV of damages
    npv_damages = sum(
        step_records[t].damage_fraction * SimOptDecisions.Utils.discount_factor(sow.discount_rate, t)
        for t in eachindex(step_records)
    )

    return (
        construction_cost=construction_cost,
        npv_damages=npv_damages,
        annual_damages=[o.damage_fraction for o in step_records],
    )
end

# Connect to the main simulate interface
function SimOptDecisions.simulate(
    params::HouseElevationParams,
    sow::HouseElevationSOW,
    policy::ElevationPolicy,
    rng::AbstractRNG,
)
    SimOptDecisions.TimeStepping.run_simulation(params, sow, policy, rng)
end
```

The `TimeStepping.run_simulation` function handles the time loop with preallocation---no `push!` needed.
Each callback has a clear responsibility, making the code easier to understand and maintain.
The `Utils.discount_factor` helper handles the discounting calculation in `finalize`.

## Running the Analysis

### Generate SOWs

First, we sample a large ensemble of possible futures.

```{julia}
#| output: false
n_sows = 1000
rng = Random.Xoshiro(42)  # reproducibility
sows = [sample_sow(rng) for _ in 1:n_sows]
```

### Evaluate Each Elevation Level

For each possible elevation (0-14 ft), we simulate across all SOWs and collect the NPV damages.

```{julia}
#| output: false
params = HouseElevationParams()
elevations = 0:14

# Store results: for each elevation, vector of NPV damages across SOWs
results = Dict{Int,Vector{Float64}}()

for elev in elevations
    policy = ElevationPolicy(Float64(elev))
    outcomes = [simulate(params, sow, policy).npv_damages for sow in sows]
    results[elev] = outcomes
end
```

## Results and Visualization

### Trade-off Curve

The key insight is the trade-off between upfront cost (elevation) and expected future damages.

```{julia}
#| label: fig-tradeoff
#| fig-cap: "Trade-off between construction cost and expected NPV damages. Each point represents an elevation level (0-14 ft)."
#| code-fold: true
let
    construction_costs = [elevation_cost(e) for e in elevations]
    expected_damages = [mean(results[e]) for e in elevations]

    fig = Figure(; size=(700, 500))
    ax = Axis(
        fig[1, 1];
        xlabel="Construction cost (fraction of house value)",
        ylabel="Expected NPV damages (fraction of house value)",
        title="Cost-Damage Trade-off by Elevation Level",
    )

    scatter!(ax, construction_costs, expected_damages; markersize=15)

    # Label points with elevation
    for (i, elev) in enumerate(elevations)
        text!(
            ax,
            construction_costs[i],
            expected_damages[i];
            text=string(elev),
            align=(:left, :bottom),
            offset=(5, 5),
        )
    end

    fig
end
```

### Total Cost Analysis

Let's look at the total cost (construction + expected damages) for each elevation level.

```{julia}
#| label: fig-total-cost
#| fig-cap: "Total expected cost (construction + NPV damages) by elevation level"
#| code-fold: true
let
    construction_costs = [elevation_cost(e) for e in elevations]
    expected_damages = [mean(results[e]) for e in elevations]
    total_costs = construction_costs .+ expected_damages

    fig = Figure(; size=(700, 500))
    ax = Axis(
        fig[1, 1];
        xlabel="Elevation (ft)",
        ylabel="Total expected cost (fraction of house value)",
        title="Total Cost by Elevation Level",
    )

    barplot!(ax, collect(elevations), total_costs; color=:steelblue)

    # Mark the minimum
    min_idx = argmin(total_costs)
    scatter!(
        ax,
        [elevations[min_idx]],
        [total_costs[min_idx]];
        color=:red,
        markersize=20,
        marker=:star5,
    )

    fig
end
```

### Uncertainty in Damages

The expected value doesn't tell the whole story. Let's examine the full distribution of outcomes.

```{julia}
#| label: fig-uncertainty
#| fig-cap: "Distribution of NPV damages for each elevation level. Box shows 25th-75th percentile; whiskers show 5th-95th percentile."
#| code-fold: true
let
    fig = Figure(; size=(800, 500))
    ax = Axis(
        fig[1, 1];
        xlabel="Elevation (ft)",
        ylabel="NPV damages (fraction of house value)",
        title="Damage Uncertainty by Elevation Level",
    )

    # Compute quantiles for each elevation
    for elev in elevations
        damages = results[elev]
        q05 = quantile(damages, 0.05)
        q25 = quantile(damages, 0.25)
        q50 = quantile(damages, 0.50)
        q75 = quantile(damages, 0.75)
        q95 = quantile(damages, 0.95)

        # Whiskers (5-95)
        lines!(ax, [elev, elev], [q05, q95]; color=:gray, linewidth=1)
        # Box (25-75)
        poly!(
            ax,
            Point2f[
                (elev - 0.3, q25), (elev + 0.3, q25), (elev + 0.3, q75), (elev - 0.3, q75)
            ];
            color=(:steelblue, 0.5),
            strokecolor=:black,
            strokewidth=1,
        )
        # Median
        lines!(ax, [elev - 0.3, elev + 0.3], [q50, q50]; color=:black, linewidth=2)
    end

    fig
end
```

### Sensitivity to Discount Rate

How does the "optimal" elevation depend on the discount rate?

```{julia}
#| label: fig-sensitivity
#| fig-cap: "Optimal elevation as a function of discount rate. Lower discount rates favor more elevation (future damages weigh more heavily)."
#| code-fold: true
let
    # Group SOWs by discount rate bins
    rate_bins = [0.015, 0.02, 0.025, 0.03, 0.035, 0.04]
    optimal_by_rate = Float64[]

    for rate in rate_bins
        # Filter SOWs near this discount rate
        filtered_sows = filter(s -> abs(s.discount_rate - rate) < 0.005, sows)
        if length(filtered_sows) < 10
            push!(optimal_by_rate, NaN)
            continue
        end

        # For these SOWs, find elevation with lowest total cost
        best_elev = 0
        best_cost = Inf
        for elev in elevations
            policy = ElevationPolicy(Float64(elev))
            outcomes = [simulate(params, sow, policy).npv_damages for sow in filtered_sows]
            total = elevation_cost(elev) + mean(outcomes)
            if total < best_cost
                best_cost = total
                best_elev = elev
            end
        end
        push!(optimal_by_rate, best_elev)
    end

    fig = Figure(; size=(600, 400))
    ax = Axis(
        fig[1, 1];
        xlabel="Discount rate",
        ylabel="Optimal elevation (ft)",
        title="Sensitivity to Discount Rate",
    )

    scatterlines!(ax, rate_bins, optimal_by_rate; markersize=12)
    fig
end
```

## Multi-Objective Optimization

The grid search above explored the trade-offs manually.
`SimOptDecisions.jl` can automate this with multi-objective optimization.

### Understanding Outcomes vs Metrics

Before setting up optimization, it's important to understand two key concepts:

- **Outcome**: The result of a *single* simulation (one policy × one SOW). This is what `simulate` returns—in our case, a `NamedTuple` with `construction_cost`, `npv_damages`, and `annual_damages`.

- **Metric**: An *aggregated* statistic computed across many SOWs for a given policy. For example, `mean(outcomes.npv_damages)` or `quantile(outcomes.npv_damages, 0.95)`.

The optimizer evaluates policies by computing metrics across the SOW ensemble, then optimizes those metrics.

### Defining a Metric Calculator

We need a function that takes a vector of outcomes and returns named metrics:

```{julia}
#| output: false
using Statistics: mean, quantile

"""
Compute metrics from outcomes across many SOWs.
Returns a NamedTuple that the optimizer can reference.
"""
function calculate_metrics(outcomes)
    damages = [o.npv_damages for o in outcomes]
    # Construction cost is now part of the outcome (same for all SOWs with same policy)
    construction = outcomes[1].construction_cost
    return (
        construction_cost=construction,
        expected_damage=mean(damages),
        cvar_95=mean(sort(damages)[(end - max(1, length(damages) ÷ 20)):end]),  # CVaR at 95%
        worst_case=maximum(damages),
    )
end
```

### Setting Up Multi-Objective Optimization

Now we can set up a problem that trades off upfront construction cost against expected future damages.
These are **conflicting objectives**: higher elevation costs more upfront but reduces damages.

```{julia}
#| output: false
using Metaheuristics: Metaheuristics  # avoid name collision with SimOptDecisions.optimize

# Create the optimization problem
prob = OptimizationProblem(
    params,
    sows,
    ElevationPolicy,
    calculate_metrics,
    [minimize(:construction_cost), minimize(:expected_damage)];
)
```

### Running the Optimization

```{julia}
# Run multi-objective optimization using NSGA-II
backend = MetaheuristicsBackend(; algorithm=:NSGA2, max_iterations=200, population_size=50)
```

```{julia}
opt_result = SimOptDecisions.optimize(prob, backend)
```

### Visualizing the Pareto Front

The optimization returns a set of Pareto-optimal solutions—policies where you cannot improve one objective without worsening another:

```{julia}
#| label: fig-pareto
#| fig-cap: "Pareto front showing trade-off between construction cost and expected NPV damages. Each point is a non-dominated elevation choice."
#| code-fold: true
let
    fig = Figure(; size=(700, 500))
    ax = Axis(
        fig[1, 1];
        xlabel="Construction cost (fraction of house value)",
        ylabel="Expected NPV damages (fraction of house value)",
        title="Pareto Front: Construction Cost vs Expected Damage",
    )

    # Extract Pareto front
    pareto_pts = collect(SimOptDecisions.pareto_front(opt_result))

    if !isempty(pareto_pts)
        construction = [obj[1] for (_, obj) in pareto_pts]
        expected = [obj[2] for (_, obj) in pareto_pts]
        elevations = [round(p[1]; digits=1) for (p, _) in pareto_pts]

        scatter!(ax, construction, expected; markersize=15, color=:steelblue)

        # Label points with elevation
        for (i, elev) in enumerate(elevations)
            text!(
                ax,
                construction[i],
                expected[i];
                text=string(elev),
                align=(:left, :bottom),
                offset=(5, 5),
            )
        end
    end

    fig
end
```

### Interpreting Results

The Pareto front reveals the fundamental trade-off:

- **Lower elevations** have lower construction costs but higher expected damages over the planning horizon
- **Higher elevations** reduce expected damages but cost more upfront
- The "best" choice depends on your **risk tolerance** and **budget constraints**

```{julia}
# Show the best policy found (by first objective)
println("Best policy found: ", opt_result.best_policy)
println(
    "Objectives: construction_cost = $(round(opt_result.best_objectives[1], digits=3)), ",
    "expected_damage = $(round(opt_result.best_objectives[2], digits=3))",
)
```

## Discussion

This toy problem illustrates several key concepts:

1. **Decision under uncertainty**: There is no single "correct" elevation. The choice depends on your beliefs about future storms, your risk tolerance, and how you value present vs. future costs.

2. **Trade-offs are fundamental**: Lower elevation saves money now but increases expected future damages. Higher elevation costs more upfront but provides protection.

3. **Deep uncertainty matters**: The uncertainty in outcomes (see @fig-uncertainty) can be substantial. Risk-averse decision-makers might prefer elevations that reduce worst-case outcomes, even if expected costs are slightly higher.

4. **Multi-objective optimization** helps explore these trade-offs systematically, revealing the Pareto frontier of non-dominated solutions.

## Next Steps

This example demonstrated:

- Defining the three core types (SOW, Policy, Params)
- Using the `TimeStepping` interface with `initialize`, `run_timestep`, `time_axis`, and `finalize` callbacks
- Connecting TimeStepping to the main `simulate` interface
- Running Monte Carlo analysis across SOWs
- Setting up multi-objective optimization with custom metrics

For more advanced usage, see the [package documentation](https://github.com/dossgollin-lab/SimOptDecisions.jl).
