---
title: "House Elevation Under Flood Risk"
subtitle: "A toy problem for decision-making under uncertainty"
author: "Doss-Gollin Lab @ Rice CEVE"
engine: julia
execute:
  exeflags: ["--project=.."]
---

## The Problem

You own a house in a flood-prone coastal area.
Each year, storm surges threaten your property.
You must decide: **how high should you elevate your house?**

Elevating higher costs more upfront, but reduces future flood damages.
The challenge is that you face deep uncertainty about:

- Future storm surge intensity (climate variability)
- The relationship between flood depth and damage
- Future economic conditions (discount rates)

This tutorial demonstrates how to frame this problem using `SimOptDecisions.jl` and explore the trade-off between upfront costs and expected damages.

::: {.callout-tip}
## What You'll Learn

This example builds on the [Investment Growth Example](investment_growth.qmd) and demonstrates:

- **Multi-dimensional uncertainty**: SOW with 6 uncertain parameters
- **Domain-specific physics**: Depth-damage curves, elevation costs
- **Multi-objective optimization**: Trading off construction cost vs expected damages
- **Handling discrete choices**: "Don't elevate" vs "elevate by X feet"

If you haven't read the Investment example, start there first.
:::

## Setup

```{julia}
#| output: false
using Revise
using SimOptDecisions
using Distributions
using Random
using CairoMakie
```

## Defining the Uncertainty

### State of the World (SOW)

Each SOW represents one possible future scenario.
We model uncertainty in:

1. **Storm surge distribution**: Annual maximum surge heights follow a Generalized Extreme Value (GEV) distribution, measured at a nearby tide gauge
2. **Depth-damage relationship**: How flood depth at the house translates to damage
3. **Discount rate**: The time value of money

```{julia}
#| output: false
struct HouseElevationSOW{T<:AbstractFloat} <: AbstractSOW
    # GEV parameters for annual max surge at the gauge
    gev_μ::T  # location (ft)
    gev_σ::T  # scale (ft)
    gev_ξ::T  # shape (dimensionless)

    # Depth-damage curve parameters (at the house)
    dd_threshold::T   # depth below which no damage occurs (ft)
    dd_saturation::T  # depth at which damage reaches 100% (ft)

    # Economic parameters
    discount_rate::T
end
```

### Sampling SOWs

We generate random SOWs by sampling from prior distributions on each parameter.
This represents our uncertainty about the true values.

We use GEV parameters inspired by the Sewells Point tide gauge in Norfolk, VA (NOAA Station 8638610).
Annual maximum water levels at this location are typically 2-4 ft above Mean Higher High Water (MHHW), with major hurricanes producing 6-8+ ft surges (e.g., Hurricane Isabel in 2003 reached ~7.9 ft above MHHW).

::: {.callout-note}
## Simplified Uncertainty Model

This is an intentionally simplified approach to uncertainty for pedagogical purposes.
In a real application, you would want to consider non-stationary extremes (climate change effects on storm intensity), spatial correlation between gauge and house, and more sophisticated uncertainty quantification methods.
:::

```{julia}
#| output: false
function sample_sow(rng::AbstractRNG)
    # GEV parameters for annual max water level at Sewells Point, Norfolk VA
    # Values are in feet above MHHW
    # Based on historical observations: typical annual max ~2.5-3 ft, major storms 6-8+ ft
    gev_μ = rand(rng, Normal(2.8, 0.3))   # location: typical annual max (ft above MHHW)
    gev_σ = rand(rng, truncated(Normal(1.0, 0.15); lower=0.3))  # scale: spread of extremes
    gev_ξ = rand(rng, truncated(Normal(0.15, 0.05); lower=-0.2, upper=0.5))  # shape: tail behavior

    # Depth-damage curve parameters (at house)
    # No damage below ~0 ft at house floor, full damage around 8 ft
    dd_threshold = rand(rng, Normal(0.0, 0.25))
    dd_saturation = rand(rng, Normal(8.0, 0.5))

    # Discount rate: uncertain, ranging from ~1% to 7%
    discount_rate = rand(rng, truncated(Normal(0.03, 0.015); lower=0.01, upper=0.07))

    return HouseElevationSOW(
        gev_μ, gev_σ, gev_ξ, dd_threshold, dd_saturation, discount_rate
    )
end
```

## The Decision: Elevation Policy

For this example, we consider a **static policy**: choose an elevation height once, at the beginning, and live with that decision for the entire planning horizon.

### Action

The action represents the decision variable—how much to elevate:

```{julia}
#| output: false
struct ElevationAction{T<:AbstractFloat} <: AbstractAction
    elevation_ft::T  # feet above current ground level (0-14)
end
```

### Policy

The policy has a single parameter: the elevation height in feet.

```{julia}
#| output: false
struct ElevationPolicy{T<:AbstractFloat} <: AbstractPolicy
    elevation_ft::T  # feet above current ground level
end

# For optimization, we need to define how to convert between policy and parameter vector
ElevationPolicy(params::AbstractVector) = ElevationPolicy(params[1])
SimOptDecisions.params(p::ElevationPolicy) = [p.elevation_ft]
SimOptDecisions.param_bounds(::Type{<:ElevationPolicy}) = [(0.0, 14.0)]
```

```{julia}
#| output: false
function SimOptDecisions.get_action(
    policy::ElevationPolicy,
    state,  # unused for static policy
    sow::HouseElevationSOW,
    t::TimeStep,
)
    return ElevationAction(policy.elevation_ft)
end
```

::: {.callout-tip}
## Handling Discrete Choices in Optimization

Real elevation choices are discrete: you either don't elevate (0 ft) or elevate to at least 3 ft (the minimum practical height).
Rather than encoding this discontinuity in the policy (which confuses convergence metrics), we use a **two-phase approach**:

1. **Phase 1**: Optimize over continuous [3, 14] ft using custom `bounds`
2. **Phase 2**: Add the "no elevation" baseline using `merge_into_pareto!`

This gives the optimizer a smooth landscape while still including discrete alternatives.
:::

## The Model

### Model Definition

The model encapsulates parameters that are **shared across all SOWs and policies**.
These are fixed characteristics of the problem, not uncertain quantities.
We use values from [Doss-Gollin et al. (2022)](https://github.com/jdossgollin/2022-elevation-robustness): a 1500 ft² house worth \$200,000 with a 70-year planning horizon.

```{julia}
#| output: false
Base.@kwdef struct HouseElevationConfig{T<:AbstractFloat} <: AbstractConfig
    horizon::Int = 70                  # planning horizon (years)
    gauge_to_house::T = 4.0            # surge level at which water reaches house floor (ft)
    house_area_ft2::T = 1500.0         # floor area in square feet
    house_value::T = 200_000.0         # house value in dollars (not land)
end
```

### Depth-Damage Function

The depth-damage function converts flood depth (at the house) to fractional damage.
We use a logistic curve with a threshold and saturation point.

```{julia}
#| output: false
function depth_damage(depth::T, threshold::T, saturation::T) where {T<:AbstractFloat}
    # No damage if water doesn't reach the floor
    depth <= threshold && return zero(T)
    # Full damage if deeply flooded
    depth >= saturation && return one(T)
    # Logistic transition between threshold and saturation
    midpoint = (threshold + saturation) / 2
    steepness = T(6) / (saturation - threshold)  # reaches ~95% at saturation
    return one(T) / (one(T) + exp(-steepness * (depth - midpoint)))
end
```

We can visualize how damage increases with flood depth:

```{julia}
#| label: fig-depth-damage
#| fig-cap: "Depth-damage function showing fractional damage as a function of flood depth at the house"
#| code-fold: true
let
    depths = range(-1, 10; length=200)
    fig = Figure(; size=(600, 400))
    ax = Axis(
        fig[1, 1];
        xlabel="Flood depth at house (ft)",
        ylabel="Damage (fraction of house value)",
        title="Depth-Damage Function",
    )

    # Show for nominal parameters
    damages = [depth_damage(d, 0.0, 8.0) for d in depths]
    lines!(ax, depths, damages; linewidth=2, label="Nominal (threshold=0, sat=8)")

    # Show uncertainty range
    for (thresh, sat) in [(-0.5, 7.5), (0.5, 8.5)]
        damages_alt = [depth_damage(d, thresh, sat) for d in depths]
        lines!(ax, depths, damages_alt; linewidth=1, linestyle=:dash, alpha=0.5)
    end

    axislegend(ax; position=:rb)
    fig
end
```

### Elevation Cost Function

The cost to elevate a house increases with height.
We use the cost model from [Doss-Gollin et al. (2022)](https://github.com/jdossgollin/2022-elevation-robustness), which is based on USACE cost estimates: a fixed base cost plus a per-square-foot cost that increases with elevation height.

```{julia}
#| output: false
"""
	elevation_cost(Δh, area_ft2, house_value)

Compute elevation cost as a fraction of house value.
Based on USACE cost estimates with piecewise-linear rates.
"""
function elevation_cost(Δh::Real, area_ft2::Real, house_value::Real)
    Δh <= 0 && return 0.0
    Δh > 14 && error("Cannot elevate more than 14 ft")

    # Cost structure from Doss-Gollin et al. (2022)
    # Base cost covers permits, engineering, temporary relocation, etc.
    base_cost = 10_000 + 300 + 470 + 4_300 + 2_175 + 3_500  # = $20,745

    # Per-square-foot rates increase with elevation height ($/ft²)
    # These are interpolated based on elevation
    thresholds = [0.0, 5.0, 8.5, 12.0, 14.0]
    rates = [80.36, 82.5, 86.25, 103.75, 113.75]

    # Linear interpolation of rate
    rate = rates[1]
    for i in 1:(length(thresholds) - 1)
        if Δh <= thresholds[i + 1]
            t = (Δh - thresholds[i]) / (thresholds[i + 1] - thresholds[i])
            rate = rates[i] + t * (rates[i + 1] - rates[i])
            break
        end
        rate = rates[i + 1]
    end

    cost_dollars = base_cost + area_ft2 * rate
    return cost_dollars / house_value
end

# Convenience wrapper using default house parameters
elevation_cost(Δh::Real) = elevation_cost(Δh, 1500.0, 200_000.0)
```

We can plot the cost curve to see how expenses grow with elevation height:

```{julia}
#| label: fig-elevation-cost
#| fig-cap: "Construction cost to elevate the house as a function of elevation height"
#| code-fold: true
let
    heights = 0:14
    costs = [elevation_cost(h) for h in heights]

    fig = Figure(; size=(600, 400))
    ax = Axis(
        fig[1, 1];
        xlabel="Elevation height (ft)",
        ylabel="Cost (fraction of house value)",
        title="Elevation Cost Function (1500 ft², \$200k house)",
    )
    scatterlines!(ax, heights, costs; markersize=10)
    fig
end
```

## Implementing the Simulation

Now we implement the simulation using the five callbacks.
This provides a structured way to define time-stepped simulations:

1. `initialize` - Create initial state (this model is stateless, so returns `nothing`)
2. `get_action` - Map policy + state to action (already defined above)
3. `run_timestep` - Execute one year: sample surge, compute damage
4. `time_axis` - Define the time points (years 1 to horizon)
5. `finalize` - Aggregate annual damages into NPV

### Initialize

Since flood damage in one year doesn't affect the house's vulnerability in the next year (beyond the elevation decision), this model has no persistent state between timesteps:

```{julia}
#| output: false
function SimOptDecisions.initialize(
    ::HouseElevationConfig, ::HouseElevationSOW, ::AbstractRNG
)
    return nothing
end
```

### Time Axis

We simulate year-by-year over the planning horizon:

```{julia}
#| output: false
function SimOptDecisions.time_axis(config::HouseElevationConfig, ::HouseElevationSOW)
    return 1:(config.horizon)
end
```

### Run Timestep

Each year, we sample a storm surge from the GEV distribution and compute the resulting damage.
The framework calls `get_action(policy, state, sow, t)` before this function, so we receive the elevation decision directly as `action`:

```{julia}
#| output: false
function SimOptDecisions.run_timestep(
    state::Nothing,
    action::ElevationAction,
    sow::HouseElevationSOW,
    config::HouseElevationConfig,
    t::TimeStep,
    rng::AbstractRNG,
)
    # Construction cost is incurred at t=1 only
    construction_cost = if t.t == 1
        elevation_cost(action.elevation_ft, config.house_area_ft2, config.house_value)
    else
        0.0
    end

    # Sample annual maximum surge at the gauge
    surge_dist = GeneralizedExtremeValue(sow.gev_μ, sow.gev_σ, sow.gev_ξ)
    surge_at_gauge = rand(rng, surge_dist)

    # Compute flood depth at house
    # gauge_to_house is the surge level at which water reaches the (unelevated) house floor
    # With elevation, we need (gauge_to_house + elevation) surge to start flooding
    flood_depth_at_house = surge_at_gauge - (config.gauge_to_house + action.elevation_ft)

    # Compute fractional damage
    damage_fraction = depth_damage(flood_depth_at_house, sow.dd_threshold, sow.dd_saturation)

    step_record = (construction_cost=construction_cost, damage_fraction=damage_fraction)
    return (nothing, step_record)
end
```

### Finalize

After all timesteps, we aggregate the annual damages into a net present value (NPV) using the SOW's discount rate:

```{julia}
#| output: false
function SimOptDecisions.finalize(
    ::Nothing,
    step_records::Vector,
    config::HouseElevationConfig,
    sow::HouseElevationSOW,
)
    construction_cost = step_records[1].construction_cost

    npv_damages = sum(
        step_records[t].damage_fraction * SimOptDecisions.Utils.discount_factor(sow.discount_rate, t)
        for t in eachindex(step_records)
    )

    return (
        construction_cost=construction_cost,
        npv_damages=npv_damages,
        annual_damages=[o.damage_fraction for o in step_records],
    )
end
```

Note: No need to override `simulate()` - the framework automatically calls these callbacks in sequence.

## Running the Analysis

### Generate SOWs

First, we sample a large ensemble of possible futures.

```{julia}
#| output: false
n_sows = 1000
rng = Random.Xoshiro(42)  # reproducibility
sows = [sample_sow(rng) for _ in 1:n_sows]
```

### Evaluate Each Elevation Level

For each possible elevation (0-14 ft), we simulate across all SOWs and collect the NPV damages.

```{julia}
#| output: false
config = HouseElevationConfig()
elevations = 0:14

# Store results: for each elevation, vector of NPV damages across SOWs
results = Dict{Int,Vector{Float64}}()

for elev in elevations
    policy = ElevationPolicy(Float64(elev))
    outcomes = [simulate(config, sow, policy).npv_damages for sow in sows]
    results[elev] = outcomes
end
```

## Results and Visualization

### Trade-off Curve

The key insight is the trade-off between upfront cost (elevation) and expected future damages.

```{julia}
#| label: fig-tradeoff
#| fig-cap: "Trade-off between construction cost and expected NPV damages. Each point represents an elevation level (0-14 ft)."
#| code-fold: true
let
    construction_costs = [elevation_cost(e) for e in elevations]
    expected_damages = [mean(results[e]) for e in elevations]

    fig = Figure(; size=(700, 500))
    ax = Axis(
        fig[1, 1];
        xlabel="Construction cost (fraction of house value)",
        ylabel="Expected NPV damages (fraction of house value)",
        title="Cost-Damage Trade-off by Elevation Level",
    )

    scatter!(ax, construction_costs, expected_damages; markersize=15)

    # Label points with elevation
    for (i, elev) in enumerate(elevations)
        text!(
            ax,
            construction_costs[i],
            expected_damages[i];
            text=string(elev),
            align=(:left, :bottom),
            offset=(5, 5),
        )
    end

    fig
end
```

### Total Cost Analysis

Let's look at the total cost (construction + expected damages) for each elevation level.

```{julia}
#| label: fig-total-cost
#| fig-cap: "Total expected cost (construction + NPV damages) by elevation level"
#| code-fold: true
let
    construction_costs = [elevation_cost(e) for e in elevations]
    expected_damages = [mean(results[e]) for e in elevations]
    total_costs = construction_costs .+ expected_damages

    fig = Figure(; size=(700, 500))
    ax = Axis(
        fig[1, 1];
        xlabel="Elevation (ft)",
        ylabel="Total expected cost (fraction of house value)",
        title="Total Cost by Elevation Level",
    )

    barplot!(ax, collect(elevations), total_costs; color=:steelblue)

    # Mark the minimum
    min_idx = argmin(total_costs)
    scatter!(
        ax,
        [elevations[min_idx]],
        [total_costs[min_idx]];
        color=:red,
        markersize=20,
        marker=:star5,
    )

    fig
end
```

### Uncertainty in Damages

The expected value doesn't tell the whole story. Let's examine the full distribution of outcomes.

```{julia}
#| label: fig-uncertainty
#| fig-cap: "Distribution of NPV damages for each elevation level. Box shows 25th-75th percentile; whiskers show 5th-95th percentile."
#| code-fold: true
let
    fig = Figure(; size=(800, 500))
    ax = Axis(
        fig[1, 1];
        xlabel="Elevation (ft)",
        ylabel="NPV damages (fraction of house value)",
        title="Damage Uncertainty by Elevation Level",
    )

    # Compute quantiles for each elevation
    for elev in elevations
        damages = results[elev]
        q05 = quantile(damages, 0.05)
        q25 = quantile(damages, 0.25)
        q50 = quantile(damages, 0.50)
        q75 = quantile(damages, 0.75)
        q95 = quantile(damages, 0.95)

        # Whiskers (5-95)
        lines!(ax, [elev, elev], [q05, q95]; color=:gray, linewidth=1)
        # Box (25-75)
        poly!(
            ax,
            Point2f[
                (elev - 0.3, q25), (elev + 0.3, q25), (elev + 0.3, q75), (elev - 0.3, q75)
            ];
            color=(:steelblue, 0.5),
            strokecolor=:black,
            strokewidth=1,
        )
        # Median
        lines!(ax, [elev - 0.3, elev + 0.3], [q50, q50]; color=:black, linewidth=2)
    end

    fig
end
```

### Sensitivity to Discount Rate

How does the "optimal" elevation depend on the discount rate?

```{julia}
#| label: fig-sensitivity
#| fig-cap: "Optimal elevation as a function of discount rate. Lower discount rates favor more elevation (future damages weigh more heavily)."
#| code-fold: true
let
    # Group SOWs by discount rate bins
    rate_bins = [0.015, 0.025, 0.035, 0.045, 0.055, 0.065]
    optimal_by_rate = Float64[]

    for rate in rate_bins
        # Filter SOWs near this discount rate
        filtered_sows = filter(s -> abs(s.discount_rate - rate) < 0.005, sows)
        if length(filtered_sows) < 10
            push!(optimal_by_rate, NaN)
            continue
        end

        # For these SOWs, find elevation with lowest total cost
        best_elev = 0
        best_cost = Inf
        for elev in elevations
            policy = ElevationPolicy(Float64(elev))
            outcomes = [simulate(config, sow, policy).npv_damages for sow in filtered_sows]
            total = elevation_cost(elev) + mean(outcomes)
            if total < best_cost
                best_cost = total
                best_elev = elev
            end
        end
        push!(optimal_by_rate, best_elev)
    end

    fig = Figure(; size=(600, 400))
    ax = Axis(
        fig[1, 1];
        xlabel="Discount rate",
        ylabel="Optimal elevation (ft)",
        title="Sensitivity to Discount Rate",
    )

    scatterlines!(ax, rate_bins, optimal_by_rate; markersize=12)
    fig
end
```

## Multi-Objective Optimization

The grid search above explored the trade-offs manually.
`SimOptDecisions.jl` can automate this with multi-objective optimization.

### Understanding Outcomes vs Metrics

Before setting up optimization, it's important to understand two key concepts:

- **Outcome**: The result of a *single* simulation (one policy × one SOW). This is what `simulate` returns—in our case, a `NamedTuple` with `construction_cost`, `npv_damages`, and `annual_damages`.

- **Metric**: An *aggregated* statistic computed across many SOWs for a given policy. For example, `mean(outcomes.npv_damages)` or `quantile(outcomes.npv_damages, 0.95)`.

The optimizer evaluates policies by computing metrics across the SOW ensemble, then optimizes those metrics.

### Defining a Metric Calculator

We need a function that takes a vector of outcomes and returns named metrics:

```{julia}
#| output: false
using Statistics: mean, quantile

"""
Compute metrics from outcomes across many SOWs.
Returns a NamedTuple that the optimizer can reference.
"""
function calculate_metrics(outcomes)
    damages = [o.npv_damages for o in outcomes]
    # Construction cost is now part of the outcome (same for all SOWs with same policy)
    construction = outcomes[1].construction_cost
    return (
        construction_cost=construction,
        expected_damage=mean(damages),
        cvar_95=mean(sort(damages)[(end - max(1, length(damages) ÷ 20)):end]),  # CVaR at 95%
        worst_case=maximum(damages),
    )
end
```

### Setting Up Multi-Objective Optimization

Now we can set up a problem that trades off upfront construction cost against expected future damages.
These are **conflicting objectives**: higher elevation costs more upfront but reduces damages.

We use the two-phase approach: optimize over [3, 14] ft (the continuous range), then add the "no elevation" baseline.

```{julia}
#| output: false
import Metaheuristics  # loads extension for SimOptDecisions.optimize

# Create the optimization problem with custom bounds [3, 14]
# This gives the optimizer a smooth, continuous search space
prob = OptimizationProblem(
    config,
    sows,
    ElevationPolicy,
    calculate_metrics,
    [minimize(:construction_cost), minimize(:expected_damage)];
    bounds=[(3.0, 14.0)],  # override default [0, 14] to avoid discrete gap
)
```

### Running the Optimization

```{julia}
# Run multi-objective optimization using NSGA-II
# parallel=true enables batch fitness evaluation across Julia threads
backend = MetaheuristicsBackend(;
    algorithm=:NSGA2, max_iterations=100, population_size=30, parallel=true
)
```

```{julia}
opt_result = SimOptDecisions.optimize(prob, backend)

# Add the "no elevation" baseline to the Pareto front
merge_into_pareto!(opt_result, prob, ElevationPolicy(0.0))
```

### Visualizing the Pareto Front

The optimization returns a set of Pareto-optimal solutions—policies where you cannot improve one objective without worsening another:

```{julia}
#| label: fig-pareto
#| fig-cap: "Pareto front showing trade-off between construction cost and expected NPV damages. Diagonal lines show iso-cost contours (total cost = construction + damages)."
#| code-fold: true
let
    fig = Figure(; size=(600, 600))
    ax = Axis(
        fig[1, 1];
        xlabel="Construction cost (fraction of house value)",
        ylabel="Expected NPV damages (fraction of house value)",
        title="Pareto Front: Construction Cost vs Expected Damage",
        aspect=1,
    )

    # Extract Pareto front from optimization
    pareto_pts = collect(SimOptDecisions.pareto_front(opt_result))

    if !isempty(pareto_pts)
        construction = [obj[1] for (_, obj) in pareto_pts]
        expected = [obj[2] for (_, obj) in pareto_pts]
        elevations = [round(p[1]; digits=1) for (p, _) in pareto_pts]

        # Draw iso-cost diagonal lines (x + y = constant)
        all_costs = construction .+ expected
        cost_range = range(minimum(all_costs) * 0.8, maximum(all_costs) * 1.1; length=6)
        for total_cost in cost_range
            # Line from (0, total_cost) to (total_cost, 0)
            xs = [0.0, total_cost]
            ys = [total_cost, 0.0]
            lines!(ax, xs, ys; color=(:gray, 0.3), linewidth=0.5, linestyle=:dash)
        end

        scatter!(ax, construction, expected; markersize=12, color=:steelblue)

        # Label a subset of points with elevation (avoid clutter)
        labeled = Set{Float64}()
        for (i, elev) in enumerate(elevations)
            # Only label if not too close to already-labeled point
            if all(abs(elev - l) > 1.5 for l in labeled)
                text!(ax, construction[i], expected[i];
                    text="$(round(Int, elev)) ft", align=(:left, :bottom), offset=(5, 5))
                push!(labeled, elev)
            end
        end
    end

    fig
end
```

### Interpreting Results

The Pareto front shows the trade-off between upfront construction cost and long-term expected damages.
Points near the origin (low cost, low damage) are infeasible—you can't get protection without paying for it.
The optimizer finds the efficient frontier: for any given construction budget, these are the elevations that minimize expected damages.

```{julia}
# Show solutions from the Pareto front
println("Pareto front solutions ($(length(opt_result.pareto_params)) points):")
for (params, objectives) in pareto_front(opt_result)
    policy = ElevationPolicy(params)
    println("  Elevation: $(round(policy.elevation_ft, digits=1)) ft → " *
            "cost=$(round(objectives[1], digits=3)), damage=$(round(objectives[2], digits=3))")
end
```

## Discussion

This model makes several simplifying assumptions worth noting:

1. **Stationary storm climate**: We sample from a fixed GEV distribution each year. In reality, sea level rise and changing storm patterns would shift this distribution over time. The framework supports time-varying SOWs via `TimeSeriesParameter` if you want to model non-stationarity.

2. **Independent annual damages**: The model assumes flood damage in one year doesn't affect vulnerability in future years. For a more realistic model, you might track cumulative damage or recovery state.

3. **Single decision point**: We choose elevation once at $t=0$. A more complex model could allow staged investments or adaptive policies that respond to observed flooding.

4. **Simplified cost model**: The elevation cost function uses USACE estimates but doesn't account for site-specific factors, permitting delays, or temporary relocation costs that vary by household.

## Summary: Adapting This Example

This example showed a more complex application of the framework. Here's what you'd change for your own problem:

### Key Components to Customize

| Component | This Example | Your Model |
|-----------|--------------|------------|
| **SOW** | Storm surge (GEV), damage curve, discount rate | Your uncertain parameters |
| **Config** | House size, value, planning horizon | Your fixed model constants |
| **Action** | Elevation height | Your decision variables |
| **Policy** | Static elevation choice | Your decision rule |
| **run_timestep** | Sample surge, compute damage | Your transition dynamics |
| **finalize** | NPV calculation | Your outcome aggregation |
| **calculate_metrics** | Expected damage, construction cost | Your optimization objectives |

### Lessons for Your Application

1. **Structure your uncertainty**: Put all uncertain quantities in the SOW. Sample many SOWs to test robustness.

2. **Separate physics from decisions**: The depth-damage curve and elevation cost functions are domain knowledge—keep them separate from the framework machinery.

3. **Validate with grid search first**: Before running optimization, explore the space manually (like we did with 0-14 ft elevations). This catches bugs and builds intuition.

4. **Use multi-objective optimization** when you have competing objectives. The Pareto front shows the efficient frontier—selecting a point is a separate decision.

5. **Handle discrete choices with two-phase optimization**: When your problem has discrete alternatives (like "don't elevate" vs "elevate 3+ ft"), use custom `bounds` to optimize the continuous region, then use `merge_into_pareto!` to add fixed baselines. This gives the optimizer a smooth landscape while still including discrete options.

For more advanced usage, see the [package documentation](https://github.com/dossgollin-lab/SimOptDecisions.jl).
