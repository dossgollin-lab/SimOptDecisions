---
title: "Investment Growth Model"
subtitle: "A minimal working example"
author: "Doss-Gollin Lab @ Rice CEVE"
engine: julia
execute:
  exeflags: ["+1.12", "--threads=auto"]
  freeze: false
  cache: false
---

## Overview

This minimal example demonstrates the core concepts of `SimOptDecisions.jl` using a simple investment growth model.
You have an initial portfolio and must decide what fraction to invest each year.
The uncertain quantity is the annual growth rate.

::: {.callout-tip}
## The Framework Pattern

Every SimOptDecisions model follows the same structure:

1. **Define your types**: Config (fixed params), SOW (uncertainty), Action (decision), Policy (decision rule), State (system state)
2. **Implement five callbacks**: `initialize`, `get_action`, `time_axis`, `run_timestep`, `finalize`
3. **Run simulations**: Call `simulate(config, sow, policy)` - the framework handles the rest
4. **Optimize**: Define metrics, create `OptimizationProblem`, call `optimize`

This example walks through each step so you can adapt it to your own problem.
:::

## Setup

```{julia}
#| output: false
using Pkg: Pkg
Pkg.activate(dirname(dirname(@__FILE__)))
```

```{julia}
#| output: false
using Revise
using SimOptDecisions
using Random
using Statistics: mean
```

## Step 1: Define Your Types

The first step in any SimOptDecisions model is defining the core types that describe your problem.

### Config — Fixed Parameters

The **Config** holds parameters that are the same across all scenarios.
These are things you know for certain or have decided upfront.

```{julia}
#| output: false
struct InvestmentConfig{T<:AbstractFloat} <: AbstractConfig
    horizon::Int            # years to simulate
    initial_value::T        # starting portfolio value
end
```

::: {.callout-note}
## Adapting for Your Model

**What goes in Config?** Model constants, time horizon, physical properties, grid sizes—anything that doesn't vary with uncertainty or decisions.

**Examples from other domains:**

- Flood model: house area, house value, planning horizon
- Inventory model: storage capacity, ordering lead time
- Energy model: plant capacities, demand profile
:::

### SOW — State of the World (Uncertainty)

The **SOW** captures exogenous uncertainty—things outside your control that affect outcomes.
Each SOW represents one possible future scenario.

```{julia}
#| output: false
struct InvestmentSOW{T<:AbstractFloat} <: AbstractSOW
    growth_rate::T  # annual growth rate (e.g., 0.05 = 5%)
end
```

::: {.callout-note}
## Adapting for Your Model

**What goes in SOW?** Random quantities you're uncertain about. You'll sample many SOWs to test policy robustness.

**Examples:**

- Flood model: storm parameters, discount rate, damage curve
- Inventory model: demand distribution, supplier reliability
- Energy model: fuel prices, renewable generation, demand shocks
:::

### Action — What You Decide

The **Action** represents a decision at a specific timestep.
Separating Action from Policy makes the framework flexible—the same policy can produce different actions based on state.

```{julia}
#| output: false
struct InvestmentAction{T<:AbstractFloat} <: AbstractAction
    invest_fraction::T  # fraction to invest (0 to 1)
end
```

### Policy — How You Decide

The **Policy** is a decision *rule*—it determines how to compute actions.
For optimization, you'll search over policy parameters to find the best rule.

```{julia}
#| output: false
struct InvestmentPolicy{T<:AbstractFloat} <: AbstractPolicy
    invest_fraction::T  # fraction to invest (0 to 1)
end

# These methods are required for optimization:
InvestmentPolicy(params::AbstractVector) = InvestmentPolicy(params[1])
SimOptDecisions.params(p::InvestmentPolicy) = [p.invest_fraction]
SimOptDecisions.param_bounds(::Type{<:InvestmentPolicy}) = [(0.0, 1.0)]
```

::: {.callout-note}
## Static vs Dynamic Policies

This is a **static policy**—the same action every timestep regardless of state.

For **dynamic policies** (actions depend on current state), `get_action` would include logic like:

```julia
function get_action(policy, state, sow, t)
    if state.value < policy.threshold
        return ConservativeAction()
    else
        return AggressiveAction()
    end
end
```
:::

## Step 2: Implement the Five Callbacks

The framework needs five functions to run your simulation.
These are the "plugs" where you insert your model logic.

### State — Tracking System Evolution

First, define what state you need to track between timesteps:

```{julia}
#| output: false
struct PortfolioState{T<:AbstractFloat} <: AbstractState
    value::T
end
```

### Callback 1: Initialize

Create the initial state at `t=0`:

```{julia}
#| output: false
function SimOptDecisions.TimeStepping.initialize(
    config::InvestmentConfig, ::InvestmentSOW, ::AbstractRNG
)
    return PortfolioState(config.initial_value)
end
```

### Callback 2: Get Action

Map (policy, state, sow, time) → action. The framework calls this automatically before each timestep:

```{julia}
#| output: false
function SimOptDecisions.get_action(
    policy::InvestmentPolicy, state::PortfolioState, sow::InvestmentSOW, t::TimeStep
)
    return InvestmentAction(policy.invest_fraction)
end
```

### Callback 3: Time Axis

Define the timesteps to simulate:

```{julia}
#| output: false
function SimOptDecisions.TimeStepping.time_axis(config::InvestmentConfig, ::InvestmentSOW)
    return 1:config.horizon
end
```

### Callback 4: Run Timestep

The core simulation logic. Receives the action computed by `get_action`:

```{julia}
#| output: false
function SimOptDecisions.TimeStepping.run_timestep(
    state::PortfolioState,
    action::InvestmentAction,
    sow::InvestmentSOW,
    config::InvestmentConfig,
    t::TimeStep,
    rng::AbstractRNG,
)
    # Portfolio growth: only invested fraction earns the growth rate
    invested = state.value * action.invest_fraction
    cash = state.value * (1 - action.invest_fraction)
    growth = invested * sow.growth_rate

    new_value = invested + growth + cash
    new_state = PortfolioState(new_value)

    # Return (new_state, step_record) - step_record can be any type
    return (new_state, (value=new_value, growth=growth))
end
```

### Callback 5: Finalize

Aggregate step records into the outcome returned by `simulate`:

```{julia}
#| output: false
function SimOptDecisions.TimeStepping.finalize(
    final_state::PortfolioState,
    step_records::Vector,
    config::InvestmentConfig,
    sow::InvestmentSOW,
)
    total_growth = sum(o.growth for o in step_records)
    return (
        final_value=final_state.value,
        total_growth=total_growth,
        annual_values=[o.value for o in step_records],
    )
end
```

::: {.callout-tip}
## That's It!

With these five callbacks implemented, `simulate(config, sow, policy)` works automatically.
No need to write a simulation loop—the framework handles it.
:::

## Step 3: Run Simulations

### Single Simulation

```{julia}
config = InvestmentConfig(10, 100.0)  # 10 years, $100 initial
sow = InvestmentSOW(0.05)              # 5% growth rate
policy = InvestmentPolicy(0.8)         # invest 80%
rng = Random.Xoshiro(42)

result = simulate(config, sow, policy, rng)
println("Final value: \$$(round(result.final_value, digits=2))")
println("Total growth: \$$(round(result.total_growth, digits=2))")
```

### Multiple SOWs — Testing Robustness

A key feature of SimOptDecisions is evaluating policies across many uncertain scenarios:

```{julia}
#| output: false
# Sample SOWs with varying growth rates (3% to 7%)
rng = Random.Xoshiro(42)
sows = [InvestmentSOW(0.03 + 0.04 * rand(rng)) for _ in 1:500]
```

```{julia}
# Run simulations across all SOWs
outcomes = [simulate(config, sow, policy, rng) for sow in sows]
final_values = [o.final_value for o in outcomes]

println("Expected final value: \$$(round(mean(final_values), digits=2))")
println("Min: \$$(round(minimum(final_values), digits=2))")
println("Max: \$$(round(maximum(final_values), digits=2))")
```

## Step 4: Optimization

### Define Metrics

The optimizer needs a function that aggregates outcomes across SOWs into metrics:

```{julia}
#| output: false
function calculate_metrics(outcomes)
    final_values = [o.final_value for o in outcomes]
    return (
        expected_value=mean(final_values),
        worst_case=minimum(final_values),
    )
end
```

::: {.callout-note}
## Outcomes vs Metrics

- **Outcome**: Result of *one* simulation (one policy × one SOW)
- **Metric**: Statistic computed by *aggregating* outcomes across many SOWs

The optimizer searches policy space to optimize metrics, not individual outcomes.
:::

### Set Up and Run Optimization

```{julia}
#| output: false
import Metaheuristics  # loads the optimization extension

prob = OptimizationProblem(
    config,
    sows,
    InvestmentPolicy,      # Policy TYPE, not instance
    calculate_metrics,
    [maximize(:expected_value)],
)

backend = MetaheuristicsBackend(; algorithm=:ECA, max_iterations=100, population_size=30)
```

```{julia}
opt_result = SimOptDecisions.optimize(prob, backend)

println("Optimal invest fraction: $(round(opt_result.best_policy.invest_fraction, digits=3))")
println("Expected value: \$$(round(-opt_result.best_objectives[1], digits=2))")
```

## Summary: Adapting This Example

To build your own model, replace these components:

| Component | This Example | Your Model |
|-----------|--------------|------------|
| **Config** | horizon, initial_value | Your fixed parameters |
| **SOW** | growth_rate | Your uncertain quantities |
| **Action** | invest_fraction | Your decision variables |
| **Policy** | invest_fraction rule | Your decision rule |
| **State** | portfolio value | What you track over time |
| **run_timestep** | portfolio growth | Your transition dynamics |
| **finalize** | total growth, final value | Your outcome metrics |

## Next Steps

For a more complex example with multi-objective optimization and visualization, see the [House Elevation Example](house_elevation.qmd).
