---
title: "2. Defining Your Model"
subtitle: "Types for configuration, uncertainty, state, actions, and policies"
engine: julia
execute:
  exeflags: ["--project=.."]
---

SimOptDecisions uses Julia's type system to structure your model.
You define five types that together describe your decision problem.

## Setup

```{julia}
#| output: false
using SimOptDecisions
using Distributions
using Random
```

## The Five Types

| Type | Purpose | Example |
|------|---------|---------|
| **Config** | Fixed parameters shared across all scenarios | House size, planning horizon |
| **Scenario** | Uncertain parameters (one possible future) | Storm intensity, discount rate |
| **State** | Model state that evolves over time | Sea level |
| **Action** | Decision at each timestep | Elevation height |
| **Policy** | Rule that maps state to actions | "Elevate to X feet" |

## Config: Fixed Parameters

The config holds parameters **shared across all scenarios and policies**.
Use `@configdef` or a plain struct—config doesn't require parameter types.

```{julia}
#| output: false
Base.@kwdef struct HouseElevationConfig{T<:AbstractFloat} <: AbstractConfig
    horizon::Int = 70
    gauge_height_above_ref::T = 0.0
    house_height_above_ref::T = 4.0
    house_area_ft2::T = 1500.0
    house_value::T = 200_000.0
end
```

## Scenario: Uncertain Parameters

Each Scenario represents one possible future. Use `@scenariodef` with `@continuous`, `@discrete`, `@categorical`, or `@timeseries` fields:

```{julia}
#| output: false
HouseElevationScenario = @scenariodef begin
    @continuous gev_μ        # GEV location (ft)
    @continuous gev_σ        # GEV scale (ft)
    @continuous gev_ξ        # GEV shape
    @continuous dd_threshold # depth below which no damage
    @continuous dd_saturation # depth at which damage = 100%
    @continuous discount_rate
end
```

This generates a struct with `ContinuousParameter{Float64}` fields. Access values with `value(scenario.gev_μ)`.

### Sampling Scenarios

```{julia}
#| output: false
function sample_scenario(rng::AbstractRNG)
    HouseElevationScenario(
        gev_μ = ContinuousParameter(rand(rng, Normal(2.8, 0.3))),
        gev_σ = ContinuousParameter(rand(rng, truncated(Normal(1.0, 0.15); lower=0.3))),
        gev_ξ = ContinuousParameter(rand(rng, truncated(Normal(0.15, 0.05); lower=-0.2, upper=0.5))),
        dd_threshold = ContinuousParameter(rand(rng, Normal(0.0, 0.25))),
        dd_saturation = ContinuousParameter(rand(rng, Normal(8.0, 0.5))),
        discount_rate = ContinuousParameter(rand(rng, truncated(Normal(0.03, 0.015); lower=0.01, upper=0.07))),
    )
end
```

## State: Evolving Conditions

Track model state that changes over time. Use `@statedef` or a plain struct:

```{julia}
#| output: false
struct SeaLevelState{T<:AbstractFloat} <: AbstractState
    msl::T  # Mean sea level relative to reference datum (ft)
end
```

## Action: What Gets Decided

The action represents the decision at each timestep:

```{julia}
#| output: false
struct ElevationAction{T<:AbstractFloat} <: AbstractAction
    elevation_ft::T
end
```

## Policy: The Decision Rule

Use `@policydef` for policies. The `@continuous` macro with bounds enables automatic `param_bounds` derivation for optimization:

```{julia}
#| output: false
ElevationPolicy = @policydef begin
    @continuous elevation_ft 0.0 14.0
end

# Constructor from parameter vector (required for optimization)
function ElevationPolicy(params::AbstractVector)
    ElevationPolicy(elevation_ft = ContinuousParameter(params[1], (0.0, 14.0)))
end
```

## Mapping Policy to Action

Define how the policy decides what action to take:

```{julia}
#| output: false
function SimOptDecisions.get_action(
    policy::ElevationPolicy,
    state::SeaLevelState,
    t::TimeStep,
    scenario::HouseElevationScenario,
)
    return ElevationAction(value(policy.elevation_ft))
end
```

## Summary

| Type | Our Definition | Purpose |
|------|----------------|---------|
| `HouseElevationConfig` | Fixed house parameters | Shared across scenarios |
| `HouseElevationScenario` | Storm/damage/discount uncertainty | Sampled to represent possible futures |
| `SeaLevelState` | Mean sea level | Tracks state over time |
| `ElevationAction` | Elevation height | The decision variable |
| `ElevationPolicy` | Static elevation rule | How to decide |

## Next Steps

In the [next section](03-running-a-simulation.qmd), we'll implement the physics (depth-damage, elevation cost) and the simulation callbacks, then run our first simulation.
