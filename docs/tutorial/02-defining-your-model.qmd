---
title: "2. Defining Your Model"
subtitle: "Types for configuration, uncertainty, state, actions, and policies"
engine: julia
execute:
  exeflags: ["--project=.."]
---

SimOptDecisions.jl uses Julia's type system to structure your model.
You define five types that together describe your decision problem.

## Setup

```{julia}
#| output: false
using SimOptDecisions
using Distributions
using Random
```

## Why Parameter Types?

SimOptDecisions requires that Scenario, Policy, and Outcome types use **parameter types** instead of plain `Float64` or `Int` fields. This enables:

- **Automatic bounds** for optimization (no manual `param_bounds` implementation)
- **Automatic flattening** for exploratory modeling and visualization
- **Consistent value extraction** via `value(p)` everywhere
- **Type safety** and clear intent

The four parameter types are:

| Type | Use Case | Example |
|------|----------|---------|
| `ContinuousParameter{T}` | Real values with bounds | `ContinuousParameter(0.5, (0.0, 1.0))` |
| `DiscreteParameter{T}` | Integer values | `DiscreteParameter(5, [1, 2, 3, 4, 5])` |
| `CategoricalParameter{T}` | Categorical/enum | `CategoricalParameter(:high, [:low, :high])` |
| `TimeSeriesParameter{T,I}` | Time-indexed data | `TimeSeriesParameter(2020:2100, values)` |

## The Five Types

| Type | Purpose | Example |
|------|---------|---------|
| **Config** | Fixed parameters shared across all scenarios | House size, planning horizon |
| **Scenario** | Uncertain parameters (one possible future) | Storm intensity, discount rate |
| **State** | Model state that evolves over time | Sea level |
| **Action** | Decision at each timestep | Elevation height |
| **Policy** | Rule that maps state to actions | "Elevate to X feet" |

## Config: Fixed Parameters

The config holds parameters that are **shared across all scenarios and policies**.
These are fixed characteristics of the problem, not uncertain quantities.

::: {.callout-note}
## Config Can Use Plain Types

Unlike Scenario and Policy, the Config type can use plain `Float64` and `Int` fields because it's not part of exploratory analysis or optimization. It's truly fixed.
:::

For house elevation, we use values from [Doss-Gollin et al. (2022)](https://github.com/jdossgollin/2022-elevation-robustness): a 1500 ft² house worth \$200,000 with a 70-year planning horizon.

```{julia}
#| output: false
Base.@kwdef struct HouseElevationConfig{T<:AbstractFloat} <: AbstractConfig
    horizon::Int = 70                       # planning horizon (years)
    gauge_height_above_ref::T = 0.0         # gauge zero above reference datum (ft)
    house_height_above_ref::T = 4.0         # house floor above reference datum (ft)
    house_area_ft2::T = 1500.0              # floor area in square feet
    house_value::T = 200_000.0              # house value in dollars (not land)
end
```

## Scenario: Uncertain Parameters

Each Scenario represents one possible future.
We model uncertainty in:

1. **Storm surge distribution**: Annual maximum surge heights follow a Generalized Extreme Value (GEV) distribution
2. **Depth-damage relationship**: How flood depth translates to damage
3. **Discount rate**: The time value of money

All fields use `ContinuousParameter` so the framework can automatically flatten scenarios for analysis:

```{julia}
#| output: false
struct HouseElevationScenario{T<:AbstractFloat} <: AbstractScenario
    # GEV parameters for annual max surge at the gauge
    gev_μ::ContinuousParameter{T}  # location (ft)
    gev_σ::ContinuousParameter{T}  # scale (ft)
    gev_ξ::ContinuousParameter{T}  # shape (dimensionless)

    # Depth-damage curve parameters (at the house)
    dd_threshold::ContinuousParameter{T}   # depth below which no damage occurs (ft)
    dd_saturation::ContinuousParameter{T}  # depth at which damage reaches 100% (ft)

    # Economic parameters
    discount_rate::ContinuousParameter{T}
end
```

::: {.callout-tip}
## Accessing Parameter Values

Use `value(p)` to extract the underlying value from any parameter type. For example, `value(scenario.gev_μ)` returns the Float64 location parameter.
:::

### Sampling Scenarios

We generate random Scenarios by sampling from prior distributions on each parameter.
This represents our uncertainty about the true values.

```{julia}
#| output: false
function sample_scenario(rng::AbstractRNG)
    # GEV parameters for annual max water level
    # Values are in feet above MHHW, based on Norfolk, VA data
    gev_μ = ContinuousParameter(rand(rng, Normal(2.8, 0.3)))
    gev_σ = ContinuousParameter(rand(rng, truncated(Normal(1.0, 0.15); lower=0.3)))
    gev_ξ = ContinuousParameter(rand(rng, truncated(Normal(0.15, 0.05); lower=-0.2, upper=0.5)))

    # Depth-damage curve parameters
    dd_threshold = ContinuousParameter(rand(rng, Normal(0.0, 0.25)))
    dd_saturation = ContinuousParameter(rand(rng, Normal(8.0, 0.5)))

    # Discount rate: uncertain, ranging from ~1% to 7%
    discount_rate = ContinuousParameter(rand(rng, truncated(Normal(0.03, 0.015); lower=0.01, upper=0.07)))

    return HouseElevationScenario(
        gev_μ, gev_σ, gev_ξ, dd_threshold, dd_saturation, discount_rate
    )
end
```

::: {.callout-note}
## Simplified Uncertainty Model

This is intentionally simplified for pedagogical purposes.
A real application would consider non-stationary extremes (climate change), spatial correlation, and more sophisticated uncertainty quantification.
:::

## State: Evolving Conditions

We track **Mean Sea Level (MSL)** as state. While MSL is constant in this example, the state structure allows future extensions where MSL could increase due to sea-level rise.

```{julia}
#| output: false
struct SeaLevelState{T<:AbstractFloat} <: AbstractState
    msl::T  # Mean sea level relative to reference datum (ft)
end
```

::: {.callout-note}
## Why Track MSL?

In this example, MSL is constant over time. However, the state structure allows future extensions—for example, sampling sea-level rise trajectories. This demonstrates the pattern of explicit state even for "nearly stateless" models.
:::

## Action: What Gets Decided

The action represents the decision variable—how much to elevate:

```{julia}
#| output: false
struct ElevationAction{T<:AbstractFloat} <: AbstractAction
    elevation_ft::T  # feet above current ground level (0-14)
end
```

## Policy: The Decision Rule

The policy has a single parameter: the elevation height in feet.
For this example, we use a **static policy**: choose an elevation once and stick with it.

Using `ContinuousParameter` with bounds means the framework can **automatically derive** `param_bounds` for optimization:

```{julia}
#| output: false
struct ElevationPolicy{T<:AbstractFloat} <: AbstractPolicy
    elevation_ft::ContinuousParameter{T}  # feet above current ground level (0-14)
end

# Constructor from parameter vector (for optimization)
function ElevationPolicy(params::AbstractVector)
    ElevationPolicy(ContinuousParameter(params[1], (0.0, 14.0)))
end
```

::: {.callout-note}
## Automatic Bounds Derivation

Because we use `ContinuousParameter` with bounds, the framework automatically derives `param_bounds` and `params` for optimization. No need to implement them manually!
:::

## Mapping Policy to Action

We need a function that determines what action to take given the current state.
For a static policy, this just returns the same elevation every time.

Note: use `value()` to extract the underlying Float64 from the parameter:

```{julia}
#| output: false
function SimOptDecisions.get_action(
    policy::ElevationPolicy,
    state::SeaLevelState,
    t::TimeStep,
    scenario::HouseElevationScenario,
)
    return ElevationAction(value(policy.elevation_ft))
end
```

## Summary

We've defined five types that structure our decision problem:

| Type | Our Definition | Purpose |
|------|----------------|---------|
| `HouseElevationConfig` | Fixed house parameters | Shared across scenarios |
| `HouseElevationScenario` | Storm/damage/discount uncertainty | Sampled to represent possible futures |
| `SeaLevelState` | Mean sea level | Tracks state over time |
| `ElevationAction` | Elevation height | The decision variable |
| `ElevationPolicy` | Static elevation rule | How to decide |

## Next Steps

In the [next section](03-running-a-simulation.qmd), we'll implement the physics (depth-damage, elevation cost) and the simulation callbacks, then run our first simulation.
