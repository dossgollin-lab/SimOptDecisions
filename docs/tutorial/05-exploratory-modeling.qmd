---
title: "5. explore()"
subtitle: "Run all policy×scenario combinations"
engine: julia
execute:
  exeflags: ["--project=.."]
---

In the previous sections, we ran simulations manually. Now we'll use `explore()` to systematically run all policy×scenario combinations and get structured results.

## Setup

```{julia}
#| output: false
#| code-fold: true
#| code-summary: "Type definitions and callbacks (click to expand)"
using SimOptDecisions
using Distributions
using Random
using CairoMakie
using Statistics

# Physics
function depth_damage(depth::T, threshold::T, saturation::T) where {T<:AbstractFloat}
    depth <= threshold && return zero(T)
    depth >= saturation && return one(T)
    midpoint = (threshold + saturation) / 2
    steepness = T(6) / (saturation - threshold)
    return one(T) / (one(T) + exp(-steepness * (depth - midpoint)))
end

function elevation_cost(Δh::Real, area_ft2::Real, house_value::Real)
    Δh <= 0 && return 0.0
    base_cost = 20_745.0
    thresholds = [0.0, 5.0, 8.5, 12.0, 14.0]
    rates = [80.36, 82.5, 86.25, 103.75, 113.75]
    rate = rates[1]
    for i in 1:(length(thresholds) - 1)
        if Δh <= thresholds[i + 1]
            t = (Δh - thresholds[i]) / (thresholds[i + 1] - thresholds[i])
            rate = rates[i] + t * (rates[i + 1] - rates[i])
            break
        end
        rate = rates[i + 1]
    end
    return (base_cost + area_ft2 * rate) / house_value
end
elevation_cost(Δh::Real) = elevation_cost(Δh, 1500.0, 200_000.0)

# Types
Base.@kwdef struct HouseConfig{T<:AbstractFloat} <: AbstractConfig
    horizon::Int = 70
    house_height::T = 4.0
    house_area_ft2::T = 1500.0
    house_value::T = 200_000.0
end

@scenariodef HouseScenario begin
    @timeseries water_levels
    @continuous dd_threshold
    @continuous dd_saturation
    @continuous discount_rate
end

function sample_scenario(rng::AbstractRNG, horizon::Int)
    # Draw GEV parameters from prior distributions
    μ = rand(rng, Normal(2.8, 0.3))
    σ = rand(rng, truncated(Normal(1.0, 0.15); lower=0.3))
    ξ = rand(rng, truncated(Normal(0.15, 0.05); lower=-0.2, upper=0.5))

    # Generate water level time series from GEV
    surge_dist = GeneralizedExtremeValue(μ, σ, ξ)
    water_levels = [rand(rng, surge_dist) for _ in 1:horizon]

    HouseScenario(
        water_levels = water_levels,
        dd_threshold = rand(rng, Normal(0.0, 0.25)),
        dd_saturation = rand(rng, Normal(8.0, 0.5)),
        discount_rate = rand(rng, truncated(Normal(0.03, 0.015); lower=0.01, upper=0.07)),
    )
end

struct HouseState{T<:AbstractFloat} <: AbstractState
    elevation_ft::T
end

struct ElevationAction{T<:AbstractFloat} <: AbstractAction
    elevation_ft::T
end

@policydef ElevationPolicy begin
    @continuous elevation_ft 0.0 14.0
end

# Functions
SimOptDecisions.initialize(::HouseConfig, ::HouseScenario, ::AbstractRNG) = HouseState(0.0)
SimOptDecisions.time_axis(config::HouseConfig, ::HouseScenario) = 1:(config.horizon)
SimOptDecisions.get_action(policy::ElevationPolicy, ::HouseState, ::TimeStep, ::HouseScenario) = ElevationAction(value(policy.elevation_ft))

function SimOptDecisions.run_timestep(
    state::HouseState, action::ElevationAction, t::TimeStep,
    config::HouseConfig, scenario::HouseScenario, rng::AbstractRNG
)
    if is_first(t)
        new_elevation = state.elevation_ft + action.elevation_ft
        construction_cost = elevation_cost(action.elevation_ft, config.house_area_ft2, config.house_value)
    else
        new_elevation = state.elevation_ft
        construction_cost = 0.0
    end

    water_level = scenario.water_levels[t]
    floor_level = config.house_height + new_elevation
    flood_depth = water_level - floor_level
    damage = depth_damage(flood_depth, value(scenario.dd_threshold), value(scenario.dd_saturation))

    return (HouseState(new_elevation), (construction_cost=construction_cost, damage_fraction=damage))
end

# Outcome with parameter wrappers (required for explore)
function SimOptDecisions.compute_outcome(
    step_records::Vector, ::HouseConfig, scenario::HouseScenario
)
    construction_cost = step_records[1].construction_cost
    npv_damages = sum(
        step_records[t].damage_fraction * discount_factor(value(scenario.discount_rate), t)
        for t in eachindex(step_records)
    )
    return (
        construction_cost = ContinuousParameter(construction_cost),
        npv_damages = ContinuousParameter(npv_damages),
        total_cost = ContinuousParameter(construction_cost + npv_damages),
    )
end
```

## The `explore()` Function

The `explore()` function runs `simulate()` for every (policy, scenario) combination and returns a **YAXArray Dataset**—a labeled multi-dimensional array.

```{julia}
config = HouseConfig()
rng = Random.Xoshiro(42)

scenarios = [sample_scenario(rng, config.horizon) for _ in 1:200]
policies = [ElevationPolicy(elevation_ft=Float64(e)) for e in 0:2:14]

result = explore(config, scenarios, policies; progress=false)

println("Result type: $(typeof(result))")
println("Cubes: $(keys(result.cubes))")
println("Shape: $(size(result[:total_cost]))")  # (n_policies, n_scenarios)
```

### Accessing Results

```{julia}
# Get specific value
first_val = first(result[:total_cost][policy=1, scenario=1])
println("Policy 1, Scenario 1: $(round(first_val, digits=3))")

# Get all outcomes for one policy
policy_3_costs = result[:total_cost].data[3, :]
println("Policy 3 mean: $(round(mean(policy_3_costs), digits=3))")
```

### Visualizing Results

```{julia}
#| label: fig-explore-boxplot
#| fig-cap: "Distribution of total costs by elevation"
#| code-fold: true
let
    elevations = 0:2:14
    n_policies = length(elevations)

    fig = Figure(; size=(800, 500))
    ax = Axis(fig[1, 1];
        xlabel="Elevation (ft)",
        ylabel="Total cost (fraction of house value)",
        title="Cost Distribution by Elevation ($(length(scenarios)) scenarios)",
        xticks=(1:n_policies, string.(elevations)))

    for (i, elev) in enumerate(elevations)
        costs = result[:total_cost].data[i, :]
        boxplot!(ax, fill(i, length(costs)), costs; width=0.6)
    end

    fig
end
```

## Executors

For large experiments, parallelize with executors:

```{julia}
#| eval: false
# Sequential (default)
result = explore(config, scenarios, policies;
    executor=SequentialExecutor())

# Multi-threaded
result = explore(config, scenarios, policies;
    executor=ThreadedExecutor())

# Distributed (across workers)
result = explore(config, scenarios, policies;
    executor=DistributedExecutor())
```

### Common Random Numbers (CRN)

CRN ensures each scenario uses the same random stream across all policies, reducing variance when comparing alternatives:

```{julia}
#| eval: false
result = explore(config, scenarios, policies;
    executor=ThreadedExecutor(; crn=true, seed=42))
```

## Storage Backends

For very large experiments, stream results to disk:

```{julia}
#| eval: false
# Save to Zarr format
result = explore(config, scenarios, policies;
    backend=ZarrBackend("results.zarr"))

# Load later
result = load_zarr_results("results.zarr")
```

## Sensitivity Analysis

With the full result matrix, we can analyze how outcomes depend on scenario parameters:

```{julia}
#| label: fig-sensitivity
#| fig-cap: "Optimal elevation varies with discount rate"
#| code-fold: true
let
    discount_rates = [value(s.discount_rate) for s in scenarios]
    elevations = 0:2:14

    # For each scenario, find the best elevation
    best_elevations = Int[]
    for s in 1:length(scenarios)
        costs = [result[:total_cost].data[p, s] for p in 1:length(elevations)]
        best_idx = argmin(costs)
        push!(best_elevations, elevations[best_idx])
    end

    fig = Figure(; size=(700, 500))
    ax = Axis(fig[1, 1];
        xlabel="Discount rate",
        ylabel="Optimal elevation (ft)",
        title="How Discount Rate Affects Optimal Elevation")

    scatter!(ax, discount_rates, best_elevations; alpha=0.5, markersize=8)
    fig
end
```

::: {.callout-tip}
## Key Insight

Lower discount rates favor higher elevations because future damages are weighted more heavily. This sensitivity to assumptions is exactly why exploratory modeling matters—different stakeholders with different assumptions will reach different conclusions.
:::

## Summary

- `explore(config, scenarios, policies)` → YAXArray Dataset
- Results indexed by `:policy` and `:scenario` dimensions
- Executors for parallelization (Sequential, Threaded, Distributed)
- CRN for variance reduction when comparing policies
- Storage backends for large experiments (InMemory, Zarr)

In the [next section](06-policy-search.qmd), we'll use `optimize()` to automatically search for Pareto-optimal policies.
