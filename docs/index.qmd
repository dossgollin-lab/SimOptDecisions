---
title: "SimOptDecisions.jl"
subtitle: "A Julia framework for simulation-based decision analysis and parametric policy search under uncertainty"
author: "Doss-Gollin Lab @ Rice CEVE"
---

::: {.callout-warning}
## Work in Progress

This package is under active development and the API may change.
:::

## Theoretical Background

This framework implements a sequential decision problem formulation:

1. **State variables $S_t$** — all information needed to model the system from time $t$ onward
2. **Decision variables $x_t$** — determined by a policy $X^\pi(S_t)$, returned as `AbstractAction`
3. **Exogenous information $W_{t+1}$** — information arriving after decision $x_t$ (from SOW)
4. **Transition function** — how $S_t$ evolves to $S_{t+1}$ given $x_t$ and $W_{t+1}$
5. **Objective** — used to evaluate the policy over time

The `get_action` function implements the policy mapping $X^\pi(S_t) \to x_t$.
The `run_timestep` function implements the transition function $S_{t+1} = f(S_t, x_t, W_{t+1})$.

## Framework Overview

```
Inputs you define:
  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────────┐
  │ Config │  │ Policy │  │  SOWs  │  │ Objectives │
  └───┬────┘  └───┬────┘  └───┬────┘  └─────┬──────┘
      │           │           │             │
      ▼           ▼           ▼             ▼
┌─────────────────────────────────────────────────────────────────┐
│ optimize()                                                      │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ evaluate_policy()                                           │ │
│ │   loops over SOWs                                           │ │
│ │ ┌─────────────────────────────────────────────────────────┐ │ │
│ │ │ simulate()                                              │ │ │
│ │ │                                                         │ │ │
│ │ │   initialize()     ───►  State                          │ │ │
│ │ │   time_axis()      ───►  times                          │ │ │
│ │ │                                                         │ │ │
│ │ │   ┌───────────────────────────────────────────────────┐ │ │ │
│ │ │   │ for t in times                                    │ │ │ │
│ │ │   │   get_action()   ───►  Action                     │ │ │ │
│ │ │   │   run_timestep() ───►  State, StepRecord          │ │ │ │
│ │ │   └───────────────────────────────────────────────────┘ │ │ │
│ │ │                                                         │ │ │
│ │ │   finalize(step_records)  ───►  Outcome                 │ │ │
│ │ └─────────────────────────────────────────────────────────┘ │ │
│ │                                                             │ │
│ │   calculate_metrics(outcomes)  ───►  Metrics                │ │
│ └─────────────────────────────────────────────────────────────┘ │
│                                                                 │
│   Objectives extract from Metrics  ───►  OptimizationResult     │
└─────────────────────────────────────────────────────────────────┘
                                                    │
                                                    ▼
                                          ┌─────────────────┐
                                          │  Pareto Front   │
                                          │ (params, values)│
                                          └─────────────────┘

Legend: You implement the 5 callbacks (initialize, time_axis, get_action,
        run_timestep, finalize) plus calculate_metrics. The framework
        handles the loops and optimization.
```

## What is SimOptDecisions.jl?

SimOptDecisions.jl is a **framework** for building simulation-optimization models in Julia.
It is **not** a turnkey solution—you write Julia code for your model. The framework provides:

1. **Structured vocabulary** — Clear concepts: Config, SOW, Policy, Action, State, StepRecord, Outcome, Metric
2. **Pluggable components** — Swap optimization backends, recording strategies
3. **Boilerplate handled** — Batching, parallel evaluation, checkpointing, type stability

**You still need to:**

- Define your types (Config, SOW, Policy, Action, State)
- Implement the five callbacks shown above
- Define your metric aggregation logic (`calculate_metrics`)

## Key Concepts

| Concept | Description |
|---------|-------------|
| **Config** | Fixed simulation parameters (don't change across scenarios) |
| **SOW** | State of the World — exogenous uncertainty for one scenario |
| **Policy** | Decision strategy that produces Actions |
| **Action** | Decision at a specific timestep |
| **State** | Internal simulation state |
| **StepRecord** | Per-timestep tracking data (returned from `run_timestep`) |
| **Outcome** | Result of one simulation (returned from `finalize`) |
| **Metrics** | Aggregate statistics across SOWs (for optimization) |
| **Objective** | What to minimize/maximize (references a Metric) |

## Installation

**Requires Julia 1.10 or later.**

```julia
using Pkg
Pkg.add(url="https://github.com/dossgollin-lab/SimOptDecisions.jl")
```

## Key Features

| Feature | Description |
|---------|-------------|
| Type-stable simulation | Zero-allocation hot loops with `NoRecorder` |
| Flexible time axes | Works with integers, floats, or `Date` ranges |
| Structured callbacks | Clean interface with five callbacks |
| Action recording | Trace simulation history including actions taken |
| Extensible optimization | Plug in Metaheuristics.jl or custom backends |
| Multi-objective support | Pareto frontier extraction |
