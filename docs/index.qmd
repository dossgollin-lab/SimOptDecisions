---
title: "SimOptDecisions"
subtitle: "A Julia framework for simulation-based decision analysis under uncertainty"
author: "Doss-Gollin Lab @ Rice CEVE"
---

::: {.callout-warning}
## Work in Progress

This package is under active development and the API may change.
:::

## What is SimOptDecisions?

SimOptDecisions is a Julia framework for simulation-based decision analysis under deep uncertainty.

You provide a simulation model and decision rules. The framework runs simulations, aggregates results across uncertain futures, and searches for optimal policies.

## Key Vocabulary

| Term | What it means |
|------|---------------|
| **Config** | Fixed parameters that don't change across scenarios |
| **Scenario** | One possible future (uncertain parameters)^[Also called "State of the World" (SOW) in decision analysis literature] |
| **Policy** | A decision rule with tunable parameters |
| **State** | Your model's internal state that evolves over time |
| **Action** | What the policy decides at each timestep |
| **Outcome** | Result of one simulation |
| **Metric** | Summary statistic across many simulations |

## How It Works

The framework is built around nested loops. Here's the full call hierarchy:

```text
┌────────┐  ┌──────────┐  ┌──────────┐  ┌────────────┐
│ Config │  │ Scenarios│  │ Policies │  │ Objectives │
└───┬────┘  └────┬─────┘  └────┬─────┘  └─────┬──────┘
    │            │             │              │
    ▼            ▼             ▼              ▼
┌─────────────────────────────────────────────────────────────────┐
│ optimize(problem, backend)                                      │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ evaluate_policy(prob, policy) — loops over scenarios        │ │
│ │ ┌─────────────────────────────────────────────────────────┐ │ │
│ │ │ simulate(config, scenario, policy)                      │ │ │
│ │ │                                                         │ │ │
│ │ │   initialize()      ───►  State                         │ │ │
│ │ │   time_axis()       ───►  times                         │ │ │
│ │ │                                                         │ │ │
│ │ │   ┌───────────────────────────────────────────────────┐ │ │ │
│ │ │   │ for t in times                                    │ │ │ │
│ │ │   │   get_action()    ───►  Action                    │ │ │ │
│ │ │   │   run_timestep()  ───►  State, StepRecord         │ │ │ │
│ │ │   └───────────────────────────────────────────────────┘ │ │ │
│ │ │                                                         │ │ │
│ │ │   compute_outcome()   ───►  Outcome                     │ │ │
│ │ └─────────────────────────────────────────────────────────┘ │ │
│ │                                                             │ │
│ │   calculate_metrics(outcomes)  ───►  Metrics                │ │
│ └─────────────────────────────────────────────────────────────┘ │
│                                                                 │
│   Pareto search over policy space  ───►  OptimizationResult     │
└─────────────────────────────────────────────────────────────────┘

explore(config, scenarios, policies) uses the same simulate() loop
but returns a YAXArray Dataset with dimensions (policy × scenario)
```

## Why Use SimOptDecisions?

**Type stability** — Your callbacks are compiled for your specific types, giving Julia's compiler full optimization opportunities.

**Structured uncertainty** — Clear separation between fixed parameters (Config), uncertain futures (Scenario), and decisions (Policy).

**Automatic exploration** — `explore()` runs all policy×scenario combinations and returns labeled multi-dimensional arrays (YAXArrays).

**Built-in optimization** — `optimize()` searches policy space for Pareto-optimal solutions using Metaheuristics.jl.

**Parallel execution** — `ThreadedExecutor` and `DistributedExecutor` for scaling to large experiments.

**Common Random Numbers** — CRN support ensures identical random streams per scenario across policies, reducing variance when comparing alternatives.

## What You Implement vs What the Framework Provides

| You Implement | Framework Provides |
|---------------|-------------------|
| Types: Config, Scenario, State, Action, Policy | `simulate()` — one simulation → Outcome |
| `initialize()`, `get_action()`, `run_timestep()` | `explore()` — all combinations → YAXArray Dataset |
| `time_axis()`, `compute_outcome()` | `optimize()` — policy search → Pareto front |
| `calculate_metrics()` for optimization | Executors, storage backends, CRN |

## Installation

Requires Julia 1.10 or later.

```julia
using Pkg
Pkg.add(url="https://github.com/dossgollin-lab/SimOptDecisions")
```

## Next Steps

→ [Tutorial](tutorial/01-the-problem.qmd) — Learn SimOptDecisions through a complete worked example (house elevation under flood risk)

→ [Quick Reference](guide/getting-started.qmd) — Checklist of types and callbacks to implement
