---
title: "SimOptDecisions"
subtitle: "A Julia framework for simulation-based decision analysis under uncertainty"
author: "Doss-Gollin Lab @ Rice CEVE"
---

::: {.callout-warning}
## Work in Progress

This package is under active development and the API may change.
:::

## What is SimOptDecisions?

SimOptDecisions is a Julia framework for conducting exploratory modeling and simulation-optimization under uncertainty.

You provide a simulation model and a parameterized policy. The framework runs your model, aggregates the results, and facilitates visualization and policy search.

Designed to be flexible but imposes just enough structure to enable type stability, fast execution, and ergonomic APIs.

## Key Vocabulary

| Term | What it means |
|------|---------------|
| **Config** | Fixed parameters that don't change across scenarios |
| **Scenario** | One possible future (your uncertain parameters)^[Also called "State of the World" (SOW) in some decision analysis literature] |
| **Policy** | A decision rule with tunable parameters |
| **Action** | What the policy decides at each timestep |
| **State** | Your model's internal state that evolves over time |
| **Outcome** | Result of one simulation |
| **Metric** | Summary statistic across many simulations |

## How It Works

The framework is built around nested loops. At the innermost level, a single simulation runs:

```
simulate(config, scenario, policy):
    state = initialize(config, scenario, rng)
    for t in time_axis(config, scenario):
        action = get_action(policy, state, t, scenario)
        state, record = run_timestep(state, action, t, config, scenario, rng)
    return compute_outcome(records, config, scenario)
```

Higher-level functions iterate over these simulations:

```
explore(config, scenarios, policies):       # Systematic evaluation
    for policy in policies:
        for scenario in scenarios:
            outcome = simulate(config, scenario, policy)
            # flatten and record

optimize(problem, backend):                  # Policy search
    for candidate_policy in search_space:
        for scenario in scenarios:
            outcome = simulate(config, scenario, candidate_policy)
        metrics = aggregate(outcomes)
        # update Pareto front
```

**Key functions:**

- `simulate(config, scenario, policy)` — run one simulation, get one outcome
- `explore(config, scenarios, policies)` — all combinations → structured table
- `optimize(problem, backend)` — search for Pareto-optimal policies

## Installation

Requires Julia 1.10 or later.

```julia
using Pkg
Pkg.add(url="https://github.com/dossgollin-lab/SimOptDecisions")
```

## Next Steps

→ [Tutorial](tutorial/01-the-problem.qmd) — Learn SimOptDecisions through a complete worked example (house elevation under flood risk)

→ [Quick Reference](guide/getting-started.qmd) — Checklist of types and callbacks to implement
