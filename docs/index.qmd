---
title: "SimOptDecisions.jl"
subtitle: "A Julia framework for simulation-optimization under uncertainty"
author: "Doss-Gollin Lab @ Rice CEVE"
---

::: {.callout-warning}
## Work in Progress

This package is under active development and the API may change.
:::

## What is SimOptDecisions.jl?

SimOptDecisions.jl is a **framework** for building simulation-optimization models in Julia.
It is **not** a turnkey solution—you write Julia code for your model. The framework provides:

1. **Structured vocabulary** — Clear concepts: Config, SOW, Policy, Action, State, StepRecord, Outcome, Metric
2. **Pluggable components** — Swap optimization backends, recording strategies
3. **Boilerplate handled** — Batching, parallel evaluation, checkpointing, type stability

**You still need to:**

- Define your actions by subtyping `AbstractAction`
- Define your policy logic (`get_action` function)
- Define your transition dynamics (`run_timestep` function)
- Implement your metric aggregation logic

::: {.callout-tip}
## Learn by Example

The best way to learn SimOptDecisions.jl is through the examples:

- **[Investment Growth](examples/investment_growth.qmd)**: A minimal working example demonstrating all core concepts
- **[House Elevation](examples/house_elevation.qmd)**: A complete tutorial with multi-objective optimization and visualization
:::

## Core Concepts

### The `simulate` Function

At the heart of SimOptDecisions.jl is the `simulate` function:

```julia
outcome = simulate(config, sow, policy)           # uses default RNG
outcome = simulate(config, sow, policy, rng)      # explicit RNG
outcome = simulate(config, sow, policy, recorder) # with recording
outcome = simulate(config, sow, policy, recorder, rng)  # full signature
```

This runs one simulation given:

- **config**: Fixed parameters that define your model (things that don't change across scenarios)
- **sow**: A State of the World representing one uncertain scenario
- **policy**: A decision rule that determines actions
- **recorder**: Optional, defaults to `NoRecorder()`. Use `TraceRecorderBuilder()` to capture simulation history
- **rng**: Optional, defaults to `Random.default_rng()`. Explicit RNG for reproducibility

By default, `simulate` calls `TimeStepping.run_simulation`, which executes the five callbacks you implement.

### Fixed Parameters (Config)

Fixed parameters are shared across all scenarios—things that don't change with uncertainty.
Subtype `AbstractConfig`:

```julia
struct MyConfig{T<:AbstractFloat} <: AbstractConfig
    horizon::Int
    initial_value::T
end
```

### States of the World (SOW)

The **State of the World (SOW)** represents exogenous information—things outside your control that affect outcomes.
Use parametric types for type stability:

```julia
struct ClimateSOW{T<:AbstractFloat} <: AbstractSOW
    temperature_trend::T
    storm_arrival_rate::T
end
```

Each SOW instance represents one possible realization of uncertain quantities.
You typically sample many SOWs to evaluate policy robustness.

For time-varying uncertainties, use `TimeSeriesParameter{T}` instead of `Vector{T}`.
This wrapper provides safe indexing via `TimeStep`.

### Actions

An **Action** represents a decision at a specific timestep. Define actions by subtyping `AbstractAction`:

```julia
struct InventoryAction{T<:AbstractFloat} <: AbstractAction
    order_quantity::T
end

struct ElevationAction{T<:AbstractFloat} <: AbstractAction
    elevation_ft::T
end
```

### Policies

A **Policy** is a parameterized decision rule—it specifies *how* to make decisions, not the decisions themselves.
Define policies by subtyping `AbstractPolicy` and implementing `get_action`:

```julia
struct InventoryPolicy{T<:AbstractFloat} <: AbstractPolicy
    reorder_point::T
    order_quantity::T
end

function SimOptDecisions.get_action(
    policy::InventoryPolicy, state, sow, t::TimeStep
)
    if state.level < policy.reorder_point
        return InventoryAction(policy.order_quantity)
    else
        return InventoryAction(zero(policy.order_quantity))
    end
end
```

For **static policies** where parameters directly define the action:

```julia
SimOptDecisions.get_action(p::ElevationPolicy, state, sow, t) = ElevationAction(p.elevation_ft)
```

### Outcomes vs Metrics

**Outcome**: The result of a *single* simulation (one policy × one SOW).
What `simulate` returns—can be any type (typically a NamedTuple).

**Metric**: A statistic computed by *aggregating outcomes across many SOWs*.
This is what the optimizer tries to minimize or maximize.

```julia
function calculate_metrics(outcomes)
    costs = [o.npv_cost for o in outcomes]
    return (
        expected_cost = mean(costs),
        worst_case = maximum(costs),
    )
end
```

## TimeStepping Interface

Most simulations iterate through discrete time steps.
Implement these five callbacks and `simulate()` will automatically use them:

| Function | Purpose | Returns | Required? |
|----------|---------|---------|-----------|
| `initialize(config, sow, rng)` | Create initial state | `state` | **Yes** |
| `get_action(policy, state, sow, t)` | Map state to action | `<:AbstractAction` | **Yes** |
| `run_timestep(state, action, sow, config, t, rng)` | Execute one step | `(new_state, step_record)` | **Yes** |
| `time_axis(config, sow)` | Define time points | Iterable | **Yes** |
| `finalize(final_state, step_records, config, sow)` | Aggregate results | `Outcome` | **Yes** |

**StepRecord**: Data tracked at each timestep, returned as the second element from `run_timestep`. All step records are collected and passed to `finalize`.

The framework calls these in order:
1. `initialize` creates the initial state
2. For each timestep:
   - `get_action` computes the action from the policy and current state
   - `run_timestep` applies the action and returns the new state
3. `finalize` aggregates all step records into the final outcome

```julia
result = simulate(config, sow, policy, Random.Xoshiro(42))
```

For non-timestepped models (closed-form solutions, external simulators), override `simulate()` directly.

## Optimization

### Evaluating Policies Across SOWs

Use `evaluate_policy` to run simulations across an ensemble of SOWs and compute aggregated metrics:

```julia
prob = OptimizationProblem(config, sows, MyPolicy, calculate_metrics, objectives)
metrics = evaluate_policy(prob, policy)  # runs simulate on all SOWs, then aggregates via calculate_metrics
```

### Setting Up Optimization

For optimization, your policy needs bounds and a vector constructor:

```julia
MyPolicy(params::AbstractVector) = MyPolicy(params[1], params[2])
SimOptDecisions.param_bounds(::Type{MyPolicy}) = [(0.0, 1.0), (0.0, 10.0)]
```

Set up the optimization problem:

```julia
using Metaheuristics

prob = OptimizationProblem(
    config,
    sows,                        # Vector of SOWs to evaluate on
    MyPolicy,                    # Policy type (not instance)
    calculate_metrics,           # Aggregation function: (outcomes) -> NamedTuple
    [minimize(:expected_cost)],  # What to optimize
)

result = SimOptDecisions.optimize(prob, MetaheuristicsBackend())
best_policy = result.best_policy
```

### Multi-Objective Optimization

For Pareto front exploration:

```julia
prob = OptimizationProblem(
    config, sows, MyPolicy, calculate_metrics,
    [minimize(:expected_cost), minimize(:worst_case)],
)

result = SimOptDecisions.optimize(prob, MetaheuristicsBackend(algorithm=:NSGA2))

for (params, objectives) in pareto_front(result)
    println("Params: $params => $objectives")
end
```

## Theoretical Background

This framework implements a sequential decision problem formulation with five elements:

1. **State variables $S_t$** — all information needed to model the system from time $t$ onward
2. **Decision variables $x_t$** — determined by a policy $X^\pi(S_t)$, returned as `AbstractAction`
3. **Exogenous information $W_{t+1}$** — information arriving after making decision $x_t$ (from SOW)
4. **Transition function** — how $S_t$ evolves to $S_{t+1}$ given $x_t$ and $W_{t+1}$
5. **Objective** — used to evaluate the policy over time

The `get_action` function implements the policy mapping $X^\pi(S_t) \to x_t$.
The `run_timestep` function implements the transition function $S_{t+1} = f(S_t, x_t, W_{t+1})$.
The SOW provides exogenous information for the entire simulation trajectory.

## Installation

```julia
using Pkg
Pkg.add(url="https://github.com/dossgollin-lab/SimOptDecisions.jl")
```

## Key Features

| Feature | Description |
|---------|-------------|
| Type-stable simulation | Zero-allocation hot loops with `NoRecorder` |
| Flexible time axes | Works with integers, floats, or `Date` ranges |
| Structured TimeStepping | Clean interface with five callbacks |
| Action recording | Trace simulation history including actions taken |
| Extensible optimization | Plug in Metaheuristics.jl or custom backends |
| Multi-objective support | Pareto frontier extraction |
