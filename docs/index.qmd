---
title: "SimOptDecisions"
subtitle: "A Julia framework for simulation-based decision analysis under uncertainty"
author: "Doss-Gollin Lab @ Rice CEVE"
---

::: {.callout-warning}
## Work in Progress

This package is under active development and the API may change.
:::

## What is SimOptDecisions?

SimOptDecisions is a Julia framework for conducting exploratory modeling and simulation-optimization under uncertainty.

You provide a simulation model and a parameterized policy. The framework runs your model, aggregates the results, and facilitates visualization and policy search.

Designed to be flexible but imposes just enough structure to enable type stability, fast execution, and ergonomic APIs.

## Key Vocabulary

| Term | What it means |
|------|---------------|
| **Config** | Fixed parameters that don't change across scenarios |
| **Scenario** | One possible future (your uncertain parameters)^[Also called "State of the World" (SOW) in some decision analysis literature] |
| **Policy** | A decision rule with tunable parameters |
| **Action** | What the policy decides at each timestep |
| **State** | Your model's internal state that evolves over time |
| **Outcome** | Result of one simulation |
| **Metric** | Summary statistic across many simulations |

## How It Works

The framework is built around nested loops. At the innermost level, a single simulation runs:

```julia
# One simulation: config × scenario × policy → outcome
function simulate(config, scenario, policy, rng)
    state = initialize(config, scenario, rng)
    records = []
    for t in time_axis(config, scenario)
        action = get_action(policy, state, t, scenario)
        state, record = run_timestep(state, action, t, config, scenario, rng)
        push!(records, record)
    end
    return compute_outcome(records, config, scenario)
end
```

Higher-level functions iterate over these simulations:

```julia
# explore: all combinations → structured table
for policy in policies
    for scenario in scenarios
        outcome = simulate(config, scenario, policy, rng)
        # flatten and record
    end
end

# optimize: search for Pareto-optimal policies
for candidate_policy in search_space
    outcomes = [simulate(config, s, candidate_policy, rng) for s in scenarios]
    metrics = calculate_metrics(outcomes)
    # update Pareto front
end
```

**Key functions:**

- `simulate(config, scenario, policy)` — run one simulation, get one outcome
- `explore(config, scenarios, policies)` — all combinations → structured table
- `optimize(problem, backend)` — search for Pareto-optimal policies

## Installation

Requires Julia 1.10 or later.

```julia
using Pkg
Pkg.add(url="https://github.com/dossgollin-lab/SimOptDecisions")
```

## Next Steps

→ [Tutorial](tutorial/01-the-problem.qmd) — Learn SimOptDecisions through a complete worked example (house elevation under flood risk)

→ [Quick Reference](guide/getting-started.qmd) — Checklist of types and callbacks to implement
