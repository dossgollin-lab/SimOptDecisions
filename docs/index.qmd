---
title: "SimOptDecisions"
subtitle: "A Julia framework for simulation-based decision analysis under uncertainty"
author: "Doss-Gollin Lab @ Rice CEVE"
---

::: {.callout-warning}
## Work in Progress

This package is under active development and the API may change.
:::

## What is SimOptDecisions?

SimOptDecisions is a Julia framework for simulation-based decision analysis under deep uncertainty.

You provide a simulation model and decision rules. The framework runs simulations, aggregates results across uncertain futures, and searches for optimal policies.

## How It Works

The framework is built around nested loops. Both `explore()` and `optimize()` call `simulate()` at their core:

```text
┌────────┐  ┌──────────┐  ┌──────────┐
│ Config │  │ Scenarios│  │ Policies │
└───┬────┘  └────┬─────┘  └────┬─────┘
    │            │             │
    ▼            ▼             ▼
┌───────────────────────────────────────────────────────────────┐
│  explore(config, scenarios, policies)                         │
│  ─ OR ─                                                       │
│  optimize(config, scenarios, policy_type, ...)                │
│                                                               │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │ for each (policy, scenario) combination                 │  │
│  │                                                         │  │
│  │  simulate(config, scenario, policy)                     │  │
│  │  ┌───────────────────────────────────────────────────┐  │  │
│  │  │   initialize()      ───►  State                   │  │  │
│  │  │   time_axis()       ───►  times                   │  │  │
│  │  │                                                   │  │  │
│  │  │   ┌─────────────────────────────────────────────┐ │  │  │
│  │  │   │ for t in times                              │ │  │  │
│  │  │   │   get_action()    ───►  Action              │ │  │  │
│  │  │   │   run_timestep()  ───►  State, StepRecord   │ │  │  │
│  │  │   └─────────────────────────────────────────────┘ │  │  │
│  │  │                                                   │  │  │
│  │  │   compute_outcome()   ───►  Outcome               │  │  │
│  │  └───────────────────────────────────────────────────┘  │  │
│  └─────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────┘
```

| Option | What it controls | Choices |
|--------|------------------|---------|
| `executor` | How to run simulations | `SequentialExecutor()`, `ThreadedExecutor()`, `DistributedExecutor()` |
| `backend` | Where to store results | `InMemoryBackend()`, `ZarrBackend(path)` |
| `trace` | Save full simulation history | `true` / `false` (default) |

## Why SimOptDecisions?

Decision-making under deep uncertainty requires running thousands of simulations across uncertain futures. SimOptDecisions handles the infrastructure so you can focus on your model:

- **You write**: physics (`run_timestep`), types (Scenario, Policy, State)
- **Framework handles**: parallel execution, storage, Pareto optimization, CRN

Your simulation code runs in tight inner loops. The framework ensures type-stable execution for maximum performance.

## Installation

Requires Julia 1.10 or later.

```julia
using Pkg
Pkg.add(url="https://github.com/dossgollin-lab/SimOptDecisions")
```

## Next Steps

→ [Tutorial](tutorial/01-the-problem.qmd) — Learn SimOptDecisions through a complete worked example (house elevation under flood risk)

→ [Quick Reference](guide/getting-started.qmd) — Checklist of types and functions to implement
